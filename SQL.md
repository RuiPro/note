## 数据库的相关概念

1. 数据库中有三个相关对象：数据库管理系统、数据库和SQL语句。其中用户使用SQL语句、通过数据库管理系统来对数据库进行管理。
2. SQL语句对于绝大多数数据库管理系统来说都是标准的、通用的。
3. 一个数据库管理系统可以维护多个数据库，一个数据库内可以容纳多个表，一个表内可以存放多种具有结构的数据。具有结构的很重要，这意味着数据库不能存放散乱的、不同种类的、毫无规律的数据。
4. 数据库管理系统需要运行在操作系统上（废话）。
5. 数据库管理系统拥有自己的账号和密码，每一个数据库也拥有自己的账号和密码，这两者是不相关的。
6. 我们需要在操作系统终端来连接数据库。当然你也可以通过数据库管理系统的GUI来连接，但不管何种方式连接数据库，都需要使用SQL语句进行管理。
7. 以MySQL为例，登录数据库管理系统的命令为`mysql -H地址 -P端口 -u数据库用户名 -p密码`，每个参数和参数内容之间可以不加空格。当不指定地址和端口时，默认连接的是本地的3306端口。

​		



## SQL语句

SQL语句是用户和数据库管理系统交互的语言。SQL语句具有以下特性：

1. 不区分大小写。SQL是大小写不敏感的。但是业内规定关键字需要使用大写，变量名称可以使用小写，这样可以获得更好的可读性。
2. SQL语句需要使用分号`;`来对每一句语句进行结束。
3. SQL使用`-- 注释`来进行单号注释，使用`/*注释*/`来进行多行注释。在使用MySQL时，还可以使用#号进行单行注释。
4. SQL语句可以分为四类：
    - DDL（Data Definition Language）语言：数据定义语言，用来定义数据库对象，如数据库、数据表和数据字段；
    - DML（Data Manipulation Language）语言：数据操作语言，用来对数据库表中的数据进行增删改查操作；
    - DQL（Data Query Language）语言：数据查询语言，用来查询数据库中表的记录；
    - DCL（Data Control Language）语言：数据控制语言，用来创建数据库用户、控制数据库的访问权限。
5. SQL语句中，**字符串类型需要使用单引号`'Stirng'`括起来**，任何自己输入的非关键字字符串都要使用这个格式。这和大部分编程语言有出入，值得注意。



#### SQL语句的标准

SQL（Structured Query Language）是一个标准化结构化查询语言，用于各种关系型数据库的管理。它是由 ANSI（American National Standards Institute）和 ISO（International Organization for Standardization）制定的标准，并受到各大数据库管理系统软件厂商的支持，包括 MySQL、SQLite 和 PostgreSQL 等。

然而，不同数据库管理系统对SQL的支持方式是不同的，还有一些数据库管理系统存在其独有的SQL语句。比如MySQL的`SHOW DATABASE;`就是其独有的，在SQLite中不支持`SHOW DATABASE;`

本文以MySQL为准。



## 准备-安装MySQL

在实际的开发中，很少使用windows系统。所以使用的是Centos 7.9系统。在初始化完毕系统后，就可以开始MySQL的安装了。

#### 一、安装MySQL Server

有两种方法进行安装。

**1. 使用yum安装**

打开MySQL的官网：www.mysql.com，在首页选择DOWNLOAD。然后拉到页面最下面，有一个MySQL Community Edition(GPL)，这是开源的社区免费版本。点进去会发现很多版本，我们选择SQL Community Server。在Releases页面选择系统。因为Centos是Red Hat系统的分支，我们选择Red Hat Enterprise Linux。然后下面会有个Install Using Yum。点进去选择和自己的操作系统对应的rpm包使用wget下载到linux目录里面。然后使用`rpm -ivh rpm包名`进行源的安装。然后使用`yum makecache`更新yum源。更新完成之后，使用`yum list | grep mysql-community`过滤出可安装的mysql版本，选择mysql-community-server进行`yum install 包名`安装即可。 

**2. 使用包安装**

同上一步进入对应系统的Releases页。往下拉，可以找到适合自己系统版本(Centos 7.9就选择Red Hat Enterprise Linux 7)和架构(x86_64)的MySQL Server进行下载(也可以下载整个捆绑包再解压)。下载到Linux之后，使用`yum localinstall 包名`进行安装即可。

#### 二、配置MySQL Server

1. 在安装完毕MySQL Server后，启动MySQL Server：

    ```
    service mysqld start
    ```

    重启和关闭分别为restart和stop。

2. 自MySQL 8.0 起，刚刚安装好的MySQL的默认用户root并不是无密码的。系统会自动分配一个密码。这个密码保存在日志(/var/log/msqld.log)里。我们可以cat这个日志文件找出。也可以之间索引：

    ```
    grep 'temporary password' /var/log/mysqld.log
    ```

3. 在获取到密码之后，就可以登录到MySQL中了：

    ```
    mysql -uroot -p
    ```

    值得一提的是，Linux下的MySQL不能在命令行中显式地输入密码，需要隐式输入。

4. 修改密码：

    ```
    ALTER USER 'root'@'localhost' IDENTIFIED BY '密码';
    ```

    MySQL的密码需要超过8位，且需要有大小写字母、数字和特殊符号进行组合。你也可以查找如何修改密码规则来设置更简单好记的密码。但是不推荐你在云服务器上这样做，这样容易被黑客盲扫攻击。

5. 添加可以远程访问的用户：

    ```
    create user 'root'@'%' IDENTIFIED WITH mysql_native password BY '密码';
    ```

    如果是MySQL 5.6及以下的版本，则命令为：

    ```
    CREATE USER 'root'@'%' IDENTIFIED BY '密码';
    ```

    

6. 为添加的远程访问的用户分配权限：

    ```
    grant all on *.* to 'root'@'%';
    ```

    这样就可以在远程访问MySQL数据库了。

7. 修改开放端口：

    在/etc/my.cnf配置文件里添加配置port = 端口，重启MySQL服务即可。注意要在防火墙中开放端口。



## 使用MySQL

### SQL数据类型

SQL支持多种数据类型，常见的有整形，单精度浮点型，双精度浮点型，可变长度字符串，固定长度字符串，长型，日期等等。不同的DBMS支持的数据类型可能略有不同。**以下数据类型为MySQL的数据类型**。可以大致分为三类：Number数值类、Text字符串类、Date日期类。

##### **Number数值类**

|    数据类型     | 大小(字节) | 描述                                                         |
| :-------------: | :--------: | :----------------------------------------------------------- |
|  TINYINT(size)  |     1      | 整形。带符号-128到127 ，无符号0到255。                       |
| SMALLINT(size)  |     2      | 整形。带符号范围-32768到32767，无符号0到65535, size 默认为 6。 |
| MEDIUMINT(size) |     3      | 整形。带符号范围-8388608到8388607，无符号的范围是0到16777215。 size 默认为9 |
|    INT(size)    |     4      | 整形。带符号范围-2147483648到2147483647，无符号的范围是0到4294967295。 size 默认为 11 |
|  BIGINT(size)   |     8      | 整形。符号的范围是-9223372036854775808到9223372036854775807，无符号的范围是0到18446744073709551615。size 默认为 20 |
|  FLOAT(size,d)  |     4      | 单精度浮点值。在 size 参数中规显示定最大位数(包括小数)。在 d 参数中规定小数的位数。 |
| DOUBLE(size,d)  |     8      | 双精度浮点值。在 size 参数中规显示定最大位数(包括小数)。在 d 参数中规定小数的位数。 |
| DECIMAL(size,d) |            | 作为字符串存储的 DOUBLE 类型，允许固定的小数点。在 size 参数中规显示定最大位数(包括小数)。在 d 参数中规定小数的位数。 |

- size参数也称为精度，d参数称为标度。精度可以用于在表示时显示总共多少位数，整形可以使用精度，如INT(4)、INT(10)。但他们在数据库中都占据4个字节大小，但输出形式有所不同。例如存入256时，INT(4)会显示0256，而INT(10)会显示为0000000256。
- 整形可以在类型后面加`UNSIGNED`关键字声明为一个无符号整形。



##### **Text字符串类**

|     数据类型     | 描述                                                         |
| :--------------: | :----------------------------------------------------------- |
|    CHAR(size)    | 保存固定长度的字符串。在括号中指定字符串的长度。最多 255 个字节。若不指定size，则size默认为1。 |
|  VARCHAR(size)   | 保存可变长度的字符串。在括号中指定字符串的最大长度。最多 255 个字节。**注释：**如果值的长度大于 255，则被转换为 TEXT 类型。 |
|     TINYTEXT     | 存放最大长度为 255 个字节的字符串。                          |
|       TEXT       | 存放最大长度为 65,535 个字节的字符串。                       |
|       BLOB       | 用于存放二进制形式的文本数据。存放最多 65,535 字节的数据。   |
|    MEDIUMTEXT    | 存放最大长度为 16,777,215 个字节的字符串。                   |
|    MEDIUMBLOB    | 用于存放二进制形式的文本数据。存放最多 16,777,215 字节的数据。 |
|     LONGTEXT     | 存放最大长度为 4,294,967,295 个字节的字符串。                |
|     LONGBLOB     | 用于存放二进制形式的文本数据。存放最多 4,294,967,295 字节的数据。 |
| ENUM(x,y,z,etc.) | 允许您输入可能值的列表。可以在 ENUM 列表中列出最大 65535 个值。如果列表中不存在插入的值，则插入空值。**注释：**这些值是按照您输入的顺序排序的。可以按照此格式输入可能的值： ENUM('X','Y','Z') |
|       SET        | 与 ENUM 类似，不同的是，SET 最多只能包含 64 个列表项且 SET 可存储一个以上的选择。 |

- 在Text字符串类型中，第1个字节，即0的位置是不用于存储数据的。
- 在Text字符串类型中，存储的限制是字符串的占用空间。这意味着选择不同的编码会使得可以存放字符串的最大长度不一样。比如TINYTEXT最多只能存放255个字节，如果使用GBK，就只能存放127个字符，因为每个GBK字符固定占两个字节；如果使用UTF8，那么存放的字符数量要根据实际来确定，因为一个UTF8汉字占3个字节，一个UTF8英文只占1个字节。除此之外，还要注意字符串末尾的\0也是一个字符。
- CHAR和VARCHAR的区别：CHAR不管输入多少字符，都占据size个空间，而VARCHAR则为输入的字符的大小。比如将'hello'字符存入CHAR(20)和VARCHAR(20)中，前者占据20个字节，后者就占据5个字节。但是使用CHAR要比VARCHAR性能更高一些。

- CAHR类型和TEXT类型有点像高级汇编语言中的char[size]和string。只不过string理论是无限大的，而TEXT有大小限制。



##### **Date日期类**

| 数据类型  | 大小(字节) | 描述                                                         |
| :-------: | :--------: | :----------------------------------------------------------- |
|   DATE    |     3      | 日期。格式：YYYY-MM-DD**注释：**支持的范围是从 '1000-01-01' 到 '9999-12-31' |
| DATETIME  |     8      | *日期和时间的组合。格式：YYYY-MM-DD HH:MM:SS**注释：**支持的范围是从 '1000-01-01 00:00:00' 到 '9999-12-31 23:59:59' |
| TIMESTAMP |     4      | *时间戳。TIMESTAMP 值使用 Unix 纪元('1970-01-01 00:00:00' UTC) 至今的秒数来存储。格式：YYYY-MM-DD HH:MM:SS**注释：**支持的范围是从 '1970-01-01 00:00:01' UTC 到 '2038-01-09 03:14:07' UTC。一般很少用。 |
|   TIME    |     3      | 时间。格式：HH:MM:SS**注释：**支持的范围是从 '-838:59:59' 到 '838:59:59' |
|   YEAR    |     1      | 2 位或 4 位格式的年。**注释：**4 位格式所允许的值：1901 到 2155。2 位格式所允许的值：70 到 69，表示从 1970 到 2069。 |





### DDL语句

DDL语句(Data Definition Language)是对数据库、数据表进行定义的语句。

数据库管理系统可以管理若干个数据库，一个数据库内可以包含若干个数据表，一个数据表内可以包含若干个数据。所以不能直接在数据库中插入数据，而是需要创建表。

在对数据库和数据表进行定义的操作时，是不允许有同名的数据库和数据表的。`[]`括起来的内容(不包括`[]`符号)可选参数，可以按照需求添加。

#### 定义数据库database

- 查询数据库：罗列已存在的数据库

    ```
    SHOW DATABASES;
    ```

- 查看数据库的编码：查看数据库管理系统中支持的编码

    常用的编码有UTF8、UTF8mb4、GBK等。其中UTF8mb4是对UTF8的超集。在MySQL中，UTF8并不像我们平时使用的UTF8，因为MySQL中的UTF8字符最大只能占3个字节，而现在的UTF8已经可以使用4个字节了，这会导致4个字节的UTF8字符不能存入数据库中。对此MySQL推出了UTF8mb4编码对UTF8进行完整的支持。

    ```
    SHOW VARIABLES LIKE 'CHARACTER%';
    ```

- 查询当前所在的数据库：查看正在使用的数据库名称

    ```
    SELECT DATABASE();
    ```

- 创建数据库：创建一个空数据库

    ```
    CREATE DATABASE [IF NOT EXISTS] 数据库名称 [DEFAULT CHARSET 字符编码] [COLLATE 排序规则];
    ```

- 使用数据库：进入该数据库中

    ```
    USE 数据库名称;
    ```

- 删除数据库：

    ```
    DROP DATABASE [IF EXISTS] 数据库名称;
    ```



#### 定义数据表table

- 查询数据表：罗列数据库中的数据表

    ```
    SHOW TABLES;
    ```

- 查询表结构：列出字段、数据类型等信息

    ```
    DESC 表名;
    ```

- 创建表：字段可以理解为表头，多个字段之间用逗号间隔。备注信息是字符串类型，需要使用单引号括起来。最后一个字段添加之后不用写逗号。

    ```
    CREATE TABLE 表名(
    	字段1 字段1类型 [字段1约束] [COMMENT '备注字段信息'],
    	字段2 字段2类型 [字段2约束] [COMMENT '备注字段信息'],
    	...
    	字段n 字段n类型 [字段n约束] [COMMENT '备注字段信息']
    )[COMMENT '备注表的信息']
    ```

- 查询创建表结构的语句：可以查看建表时的指令

    ```
    SHOW CREATE TABLE 表名;
    ```

- 添加字段：

    ```
    ALTER TABLE 要添加字段的表名 ADD 字段名 字段类型 [COMMENT '备注字段信息'] [约束];
    ```

- 修改字段：

    - 修改字段类型：

        ```
        ALTER TABEL 表名 MODIFY 要修改类型的字段名 新字段类型;
        ```

    - 修改字段名字和字段类型：

        ```
        ALTER TABLE 表名 CHANGE 旧字段名 新字段名 字段类型 [COMMENT '备注字段信息'] [约束];
        ```
        
    
- 删除字段：

    ```
    ALTER TABLE 表名 DROP 字段名;
    ```

- 修改表名：

    ```
    ALTER TABLE 表名 RENAME TO 新表名;
    ```

- 删除表：

    ```
    DROP TABLE [IF EXISTS] 要删除的表名;
    ```

- 重构表：删除表并重新创建该表，表内的数据会被清空。

    ```
    TRUNCATE TABLE 表名;
    ```




### DML语句

DML语句(Data Manipulation Language)是对数据库，更准确地说是数据表中的数据进行操作的语句，主要功能有插入数据、修改数据和删除数据。

- 往数据表中添加(插入)数据：

    插入单条数据：

    ```
    INSERT INTO 表名 (字段列1,字段列2,...字段列n) VALUES (值1,值2,...值n);
    ```

    当然也可以省略字段列表，如下：

    ```
    INSERT INTO 表名 VALUES (值1,值2,...值n);
    ```

    **注意**：值需要和字段一一对应才能插入。如果想要对某个值进行置空，需要使用NULL。

    批量插入数据：

    ```
    INSERT INTO 表名 (字段列1,字段列2,...,字段列n) VALUES (值1,值2,...值n),(值1,值2,...值n)...;
    ```

    也可以省略字段列表：

    ```
    INSERT INTO 表名 VALUES (值1,值2,...值n),(值1,值2,...值n)...;
    ```

- 修改数据表中的数据：

    ```
    UPDATE 表名 SET 字段名1=值1, 字段名2=值2,..., 字段名n =值n [WHERE 条件表达式 ];
    ```

    其中WHERE限定是可选的，如果为空，则表示修改整张表中的数据。添加限定条件(比如 WHERE 字段列1 = 某值)后，将只修改对应的那条数据。

- 删除表中的数据：

    ```
    DELETE FROM 表名 [WHERE 条件表达式 ];
    ```

    其中WHERE限定是可选的，如果为空，则表示删除整张表中的数据。添加限定条件(比如 WHERE 字段列1 = 某值)后，将只删除对应的那条数据。

    DELETE删除整张表中的数据和前面DDL语句中的重构表的区别：DELETE是一条一条地删除数据，且会记录到log中，重构只会执行一次，也就只会在log中留下一条记录。所以后者花的时间会更少。



### DQL语句

DQL语句(Data Query Language)是用于查询数据库中的数据的语句。在正常的业务中，使用DQL语句的频率是最高的。

DQL语句仅有一个关键字SELECT。SELECT 语句用于从数据库中选取数据，并且将按照约束选取的数据放在一个结果表中(也称为结果集)。结果集是临时的，不能进行修改。

SELECT从表中读取数据的语法如下：

```
SELECT
	字段列表
FROM
	表名
WHERE
	条件列表(可选)
GROUP BY
	分组字段列表(可选)
HAVING
	分组后条件列表(可选)
ORDER BY
	排序字段列表(可选)
LIMIT
	分页参数(可选);
```

值得一提的是，这些关键字的编写顺序是固定的，不能随便调换。



#### 一阶：使用SELECT查询

SELECT关键字用于输出表内容，类似于C里面的printf()函数，不过其输出内容是以表格的形式呈现的。

我们可用使用`SELECT 值`来输出某个值，这个值可以是字段(列表)，也可以是常量、表达式和函数。譬如我们可以使用`SELECT VERSION()`的形式来输出SQL的版本。

`SELECT 字段列表 FROM 表名`是DQL语句的基础。任何DQL语句都要包含这两个关键字。

SELECT返回的是一个结果集，这个结果集也是由字段和数据组成的。我们可以自定义返回哪些字段的数据：

```
SELECT 字段1,字段2,...字段n FROM 表名;
```

如果需要返回所有字段的数据，也可以使用`*`代替字段列表。但这种方式可读性较低，在团队开发中慎用。

```
SELECT * FROM 表名;
```

如果字段名可读性低，还可以指定字段别名，提高可读性：

```
SELECT 字段1 [AS 别名1],字段2 [AS 别名n],...字段n [AS 别名n] FROM 表名;
```

其中AS可以省略，之间跟别名：

```
SELECT 字段1 [别名1],字段2 [别名n],...字段n [别名n] FROM 表名;
```

如果要对字段内的数据去除重复记录，需要在SELECT后面加DISTINCT关键字：

```
SELECT  DISTINCT 字段列表 FROM 表名;
```



#### 二阶：带条件的SELECT查询

SQL中，可以对SELECT添加条件，用于过滤数据。使用WHERE关键字+条件。条件由以下运算符和关键字组成：

|       运算符        |                     功能                     |
| :-----------------: | :------------------------------------------: |
|          >          |               限定大于值的数据               |
|          <          |               限定小于值的数据               |
|         >=          |             限定大于小于值的数据             |
|         <=          |             限定小于等于值的数据             |
|          =          |       限定等于值的数据，不能判断NULL值       |
|      <> 或 !=       |      限定不等于值的数据，不能判断NULL值      |
| BETWEEN 值1 AND 值2 | 限定在值1到值2范围内的值的数据，值1需小于值2 |
| IN(值1,值2,...值n)  |         限定拥有列表中存在的值的数据         |
|     LIKE 占位符     | 模糊匹配值(\_匹配单个字符，%匹配任意个字符)  |
|       IS NULL       |               限定值为空的数据               |
|      AND 或 &&      |                逻辑运算符 且                 |
|     OR 或 \|\|      |                逻辑运算符 或                 |
|      NOT 或 !       |                逻辑运算符 非                 |
|         <=>         |           安全等于，可以判断NULL值           |

比较运算符需要搭配字段和约束值使用。比如下条语句表示筛选出字段x的值大于等于20的数据。

```
SELECT * FROM 表名 WHERE 字段x >= 20;
```

- 特殊：IS NULL的非语句并不是`! IS NULL`，也不是`!=NULL`，而是`IS NOT NULL`，不过我们可用使用安全等于，即<=> NULL。

如需使用多个条件，需要使用逻辑运算符连接，如：

```
SELECT * FROM 表名 WHERE 字段x >= 20 && 字段x < 50;
```

模糊匹配条件下，可以将\_号和%号添加到条件值中。添加后，\_匹配任意单个字符，%匹配任意的多个字符。举例：

```
-- 匹配字段为两个字符的数据
SELECT * FROM 表名 WHERE 字段x LIKE '__';
-- 匹配字段为以“.”号结尾的数据
SELECT * FROM 表名 WHERE 字段x LIKE '%.';
-- 匹配字段内含有"aaa"的数据
SELECT * FROM 表名 WHERE 字段x LIKE '%aaa%';
-- 匹配字段内倒数第二位是"@"符号的数据
SELECT * FROM 表名 WHERE 字段x LIKE '%@_';
```

- 值得一提的是，在MySQL中对bool值也有隐式转换，即0转换成假，非0转换成真。



#### 三阶前置：聚合函数

聚合函数和前面讲到的操作都不同。聚合函数是**以关键字为单位的、可以横跨多条数据**的函数，而在之前的操作中，都是对单条数据进行操作，数据之间没有存在任何的关联关系。聚合函数返回的结果集只有一个值。

有以下常用的聚合函数：

| 函数  |   功能   |
| :---: | :------: |
| count | 统计数量 |
|  max  |  最大值  |
|  min  |  最小值  |
|  avg  |  求平均  |
|  sum  |   求和   |

**所有聚合函数都不会对NULL进行处理。**

使用聚合函数的语法为

```
SELECT 聚合函数(字段列表) FROM 表名;
```

如查询所有数据中字段x的平均值：

```
-- 对字段x的所有数据值进行求平均
SELECT avg(字段x) FROM 表名;
```

聚合函数可以和条件搭配使用，如：

```
-- 对字段x的所有大于0的
数据值进行求平均
SELECT avg(字段x) FROM 表名 WHERE 字段x > 0;
```



#### 三阶：分组SELECT查询

分组查询的关键字为GROUP BY和HAVING条件，根据一个或多个字段的数据值对结果集进行分组，字段值相同的数据会被归类到同一组中。

分组查询多和聚合函数结合使用，当存在分组时，聚合函数可以对每一组的数据分别进行计算。

分组SELECT的语法：

```
SELECT 字段列表 FROM 表名 [WHERE 条件] GROPUP BY 分组字段名 [HAVING 分组后的过滤条件];
```

比如我们有一张员工表(employee)，字段有ID(id)、姓名(name)、性别(sex)、年龄(age)、电话(telephone)、身份证号(idcard)、部门(department)和薪资(salary)。我们要统计男性员工的平均薪资和女性员工的平均薪资，该怎么操作？如果我们仅仅使用WHERE条件对性别进行限定，则至多只能获取一个性别的信息，另一个性别则要修改WHERE条件才能获取，且不能输出到一张表里。

```
SELECT avg(salary) FROM employee WHERE sex = '男';
SELECT avg(salary) FROM employee WHERE sex = '女';
```

那么如果我想把男女的平均薪资**一起输出**到一张表里，该怎么做？这时候分组就派上用场了。我们可以对性别**进行分组操作**，即分为男性组和女性组，再对这两个组进行求平均聚合函数即可。

```
SELECT sex,avg(salary) FROM employee GROPUP BY sex;
```

SELECT返回的字段一般为分组字段和聚合函数，因为返回其他字段是没有意义的。比如这里是对性别进行分组，如果我们再添加一个姓名字段，单个姓名和性别组没有任何的参考意义。



更进一步地，我们想要查询薪资水平为6000以上的男性员工个数大于等于5的部门，该如何解决？我们需要对WHERE条件对薪资水平进行限定，需要对部门进行分组，还要统计男性员工的个数，还要根据男性员工的个数进行筛选部门...该如何实现？

如果我们只使用WHERE，是不可能实现这个业务的。因为WHERE只能对已有的字段进行筛选，不能对我们分的组进行筛选。这时候我们就要使用HAVING条件了。

```
-- 这条只是查询出各部门薪资水平为6000以上的男性员工个数
SELECT department,count(*) FROM employee WHERE salary >= 6000 GROUP BY department;
-- 加上HAVING条件之后，我们可以进一步对组进行筛选，只查看分组后员工个数大于等于5个的部门
SELECT department,count(*) FROM employee WHERE salary >= 6000 GROUP BY department HAVING count(*) >= 5;
```

这条语句的执行顺序是：先筛选出薪资大于等于6000的员工，再根据部门分组，然后部门内各组使用聚合函数count(*)求值，最后再根据各部门的值对部门进行再一次筛选。

**由此可见，HAVING并不是用来对已有的关键字进行筛选的，而是对我们分组之后的结果集进行筛选，其筛选对象一般是我们分的组。如果我们未进行分组操作，那么默认作用对象就是整体。因为我们分组依靠的是多种数据，所以HAVING经常结合聚合函数来使用。相比之下，WHERE只能对已有的数据进行筛选，而且针对的是单个数据的数据值，因此WHERE不能使用聚合函数。**



- 举例：巧用分组求冲突

    给定一个用户表User，有用户ID和用户名两个字段。要求选择出用户名有冲突的用户(假设所有用户名都为小写英文构成)。如

    | user_id | user_name |
    | :-----: | :-------: |
    |    1    |   jack    |
    |    2    |   rose    |
    |    3    |   jack    |

    很明显，jack重名了。但是怎么查询呢？

    我们不妨想一想，重名的用户名出现的次数大于1，而不重名的用户出现的次数等于1。我们可以使用count来求出每个用户名出现的次数，然后再筛选出其中用户名出现次数大于1的用户名。

    ```
    select user_name, count(user_name) from User group by user_name;		-- 求出每个用户名出现的次数
    select user_name from
    (
      select user_name, count(user_name) as num from User group by user_name;
    )
    where num > 1;															-- 筛选出用户名出现的次数大于1的用户名
    ```

    根据这个思路，我们可以使用HAVING条件来简化上述语句：

    ```
    select user_name from User group by user_name having count(user_name) > 1；
    ```

    



#### 四阶：排序SELECT查询

排序指对结果集的某些字段进行排序后再输出，是数据库中的一个非常重要的模块，是不少业务的依赖。MySQL中，排序的关键字为ORDER BY。同时，MySQL支持多个字段的排序，这意味着如果多个数据的某字段值相等时，会按照下一个字段进行排序。如果没有指定下一个字段，将会按照插入数据库中的先后顺序进行输出。语法为：

```
SELECT 字段列表 FROM 表名 ORDER BY 字段1 排序方式1 字段2 排序方式2...；
```

其中有两种排序方式：ASC为升序，也是默认值，在未指定排序方式时会使用升序。DESC为降序。升序和降序的含义是随着数据的输出，值是呈升/降排序的。

- 如果值为NULL，会在结果集的开头或者末尾进行汇总。
- ORDER BY可以使用SELECT中用AS指定的别名。
- ORDER BY可以使用聚合函数。



#### 五阶：分页SELECT查询

分页查询是指对结果集进行分页输出。有时候我们不想一下子展示很多的数据，或者说我们在排序后想要前/后几条数据，这时候就用到分页输出了。分页的关键字为LIMIT。语法为：

```
SLELECT 字段列表 FROM 表名 LIMIT 分页的起始位置,输出的数据量;
```

比如`SLELECT 字段列表 FROM 表名 LIMIT 15,10;`就意味着从15开始(包括15)，输出10条数据，即输出结果集里位置为15-24的数据。注意，MySQL中，分页的起始位置是由0开始的，且在未指定起始位置的情况下，默认也是0。



#### 尾节：DQL执行顺序

对于一个DQL语句来说，它的执行顺序是这样的：

```
SELECT
	字段列表
FROM
	表名
WHERE
	条件列表(可选)
GROUP BY
	分组字段列表(可选)
HAVING
	分组后条件列表(可选)
ORDER BY
	排序字段列表(可选)
LIMIT
	分页参数(可选);
```

1. DBMS最先执行的是`FROM 表名`，确定要对哪个表进行查询操作；
2. 接着执行`WHERE 条件列表`，进行数据的筛选；
3. 执行`GROUP BY 分组字段列表`，对筛选后的数据进行分组，如果有分组，则结果集会变成组；
4. 执行`HAVING 分组后条件列表`，对分组后的组进行筛选；
5. 执行`SELECT 字段列表`，确定要返回哪些字段；
6. 执行`ORDER BY 排序字段列表`，对结果集进行排序；
7. 执行`LIMIT 分页参数`，对排序后的结果集进行分页；
8. 输出。

因为`SELECT 字段列表`在`WHERE 条件列表`、`GROUP BY 分组字段列表`和`HAVING 分组后条件列表`之后，因此这些在`SELECT 字段列表`之前执行的语句就不能使用`SELECT 字段列表`时用AS指定的字段别名；而在`SELECT 字段列表`之后执行的`ORDER BY 排序字段列表`则可以使用。



### DCL语句

DCL语句(Data Control Language)是一种可对数据库访问权进行控制的指令，它可以管理用户，控制特定用户账户对数据表、查看表、存储程序、用户自定义函数等数据库对象的控制权。

MySQL不使用任何配置文件保存用户，相反地，MySQL使用的是一个在安装后默认就存在的数据库：mysql来维护用户信息。

MySQL中用户由用户名和主机构成。用户名就是用户名，主机代表了该用户访问数据库的网络位置，如果为localhost，说明该用户只能在本地访问数据库。多个用户中用户名和主机名一致才会被认为是同一用户。

#### 用户管理

1. 查询用户列表

    ```
    USE mysql;
    SELECT * FROM user;
    ```

2. 创建用户 

    ```
    CREATE USER '用户名'@'主机名' IDENTIFIED BY '密码';
    ```

3. 修改用户密码 

    ```
    ALTER USER '用户名'@'主机名' IDENTIFIED WITH mysql_native_password BY  '密码';
    ```

4. 删除用户 

    ```
    DROP USER '用户名'@'主机名';
    ```

    

#### 权限控制

默认情况下，MySQL的新用户只能访问系统数据库。我们可以为用户分配权限。

MySQL中有以下几种常用的权限：

|        权限         |          说明          |
| :-----------------: | :--------------------: |
| ALL、ALL PRIVILEGES |        所有权限        |
|       SELECT        |        查询数据        |
|       INSERT        |        插入数据        |
|       UPDATE        |        修改数据        |
|       DELETE        |        删除数据        |
|        ALTER        |      修改表(字段)      |
|        DROP         | 删除数据库/数据表/视图 |
|       CREATE        |   创建数据库/数据表    |

1. 查询权限

    ```
    SHOW GRANTS FOR '用户名'@'主机名';
    ```

2. 授予权限

    ```
    GRANTS 权限列表 ON 数据库名.表名 TO '用户名'@'主机名';
    ```

    如果要授予所有数据库/数据表的权限，则可以使用\*代替数据库名/表名。

3. 撤销权限

    ```
    REVOKE 权限列表 ON 数据库名.表名 FROM '用户名'@'主机名';
    ```





## MySQL函数

函数是指一段可以调用的程序或代码。在使用DQL语句时的聚合函数就是函数的一种。MySQL为我们提供了丰富的函数。

MySQL中函数分为两种函数，一种是单行函数，针对单个数据进行函数执行；另一种是分组函数，也称聚合函数，前面我们已经在DQL语句学习过了。单行函数又可以分为四种小类，分别是字符串函数、数值函数、日期函数、流程控制函数。他们可以对表中的某个字段的数据进行处理，然后再输出到结果集中，或将函数结果应用到其他方面中。

因为函数太多了，这里不一一列举，你可以参考MySQL的官方文档，也可以上网找资料。

比如函数UPPER()是将字符串中所有的小写字母转换成大写，那我们就可以使用下条语句来让字段x(CHAR (20)类型)输出的内容全部转为大写。

```
SELECT UPPER(字段x) FROM 表名;
```

我们也可以将函数作用于修改数据操作中，我们就可以使用下条语句来让字段x保存的数据内容全部转为大写。

```
UPDATE 表名 SET 字段x = UPPER(字段X);
```



## MySQL约束

约束是用来限制表中的数据的、作用在表中字段上的规则，通常在创建表中定义，也可以在创建表后添加，但不管是什么时候添加约束，都应保证在插入数据之前添加。约束可以保证数据库中数据的正确、有效和完整性(针对外键)。当存入不符合规则的数据时，DBMS会拒绝存入该非法数据并报错。

常用的约束有以下几种。

|     约束     |   关键字    |                             描述                             |
| :----------: | :---------: | :----------------------------------------------------------: |
|   非空约束   |  NOT NULL   |                  限制该字段的数据不能为NULL                  |
|   唯一约束   |   UNIQUE    |           限制该字段的数据都是独一无二、不可重复的           |
|   主键约束   | PRIMARY KEY | 添加主键约束的字段成将为数据的标识，要求非空且唯一。**一张表只能存在一个主键** |
|   默认约束   |   DEFAULT   |   DEAFULT 默认值，当输入的数据该字段为空时，将会使用默认值   |
| 检查约束[^*] |    CHECK    |     可添加自定义条件CHECK(条件)，满足条件的值才会被录入      |
|   外键约束   | FOREIGN KEY |      让两张表的数据进行连接，保证数据的一致性和完整性。      |

- 当我们把数值字段设为主键约束且需要其自动增长时，我们可以给该主键设置AUTO_INCREMENT关键字让其自动增长。但是这个自动增长在插入数据失败时也会增长，且在删除数据时不会重新排列。
- 主键和唯一约束的区别：
    - 主键和唯一都具有唯一性；
    - 主键不能为空，而唯一可以为空，但唯一最多只能插入一个空值；
    - 主键和唯一都可以设置多个字段，当主键设置为多个字段时，并不是有多个主键，而是这多个字段合并起来成为了主键，这多个字段中有任何两个数据的相同字段相同都被认为是不唯一。

[^*]:在MySQL 8.0.16版本之后才有此功能。

使用约束：

1. 我们可以在建表时就使用约束。

    在建表时添加的约束分为两种，一种是列级约束，一种是表级约束。列级约束是在定义字段时就跟在字段后面的约束，表级约束是在写完字段列表后，再写的约束。列级约束除了外键约束之外都会生效，而**表级约束的语法不能有非空约束和默认约束**。

    列级约束的形式如下：

    ```
    CREATE TABLE 表名(
    	字段1 字段1类型 字段1约束 [COMMENT '备注字段信息'],
    	字段2 字段2类型 字段2约束 [COMMENT '备注字段信息'],
    	...
    	字段n 字段n类型 字段n约束 [COMMENT '备注字段信息'],
    	[CONSTRAINT] 外键约束的自定名称 FOREIGN KEY(字段名) REFERENCES 主表(要捆绑的主表的字段名) ON UPDATE 更新外键时的行		为 ON DELETE 删除外键时的行为
    )[COMMENT '备注表的信息']
    ```

    表级约束的形式如下：

    ```
    CREATE TABLE 表名(
    	字段1 字段1类型 [COMMENT '备注字段信息'],
    	字段2 字段2类型 [COMMENT '备注字段信息'],
    	...
    	字段n 字段n类型 [COMMENT '备注字段信息'],
    	[CONSTRAINT] 约束(要施加约束的字列表),
    	[CONSTRAINT] 约束(要施加约束的字列表),
    	...
    	[CONSTRAINT] 约束(要施加约束的字段列表),
    	[CONSTRAINT] 外键约束的自定名称 FOREIGN KEY(字段名) REFERENCES 主表(要捆绑的主表的字段名) ON UPDATE 更新外键时的行		为 ON DELETE 删除外键时的行为
    )[COMMENT '备注表的信息']
    ```

    使用表级约束可以为一个约束设置多个字段，包括主键约束。

    更新/删除外键时的行为常用的有以下四种：

    - 1、RESTRICT：父表数据被删除，会阻止删除。默认就是这一项。
    - 2、NO ACTION：在MySQL中，同RESTRICT。
    - 3、CASCADE：级联删除，一起更新/删除捆绑的数据。
    - 4、SET NULL：父表数据被删除，子表数据会设置为NULL。

2. 我们也可以在建表后添加约束

```
-- 添加字段约束
-- 列级约束可用的方法
ALTER TABLE 表名 CHANGE 旧字段名 [新字段名] 字段类型 [COMMENT '备注字段信息'] [约束];
-- 表级约束可用的方法
ALTER TABLE 表名 ADD CONSTRAINT [约束的自定名称] 约束(字段列表);
-- 添加外键约束
ALTER TABLE 表名 ADD CONSTRAINT FOREIGN KEY(字段名) REFERENCES 主表(要捆绑的主表的字段名) ON UPDATE 更新外键时的行为 ON DELETE 删除外键时的行为;
```

3. 删除约束

```
-- 删除非外键约束
ALTER TABLE 表名 CHANGE 旧字段名 [新字段名] 字段类型 [COMMENT '备注字段信息'] [NULL];
-- 删除外键约束
ALTER TABLE 表名 DROP CONSTRAINT FOREIGN KEY;
```

最后提一嘴，这一段看不懂无所谓，你只要了解如何添加约束就行了，因为一般在添加约束的时候往往没有添加数据，如果需要修改条件，我的建议是直接使用`SHOW CREATE TABLE 表名;`拿到创建时的语句，然后删除表，再创建一个新表。



## MySQL连接查询

连接查询也称多表查询，是DQL语句的一种。

为什么要有多表？因为我们在设计业务的时候，往往会分为多个模块，再为每个模块设计表结构。但是这些模块并不是独立的，他们之间必然会存在某种关联。譬如这个业务场景：学校要构建一个师生信息数据库，需要分为学院、老师、学生、课程四个表。其中老师、学生中有一个所在学院字段来保存所在学院，老师有一个领导字段来保存领导(领导也是老师)是谁，学生有一个老师字段来保存班主任老师是谁，学生可以选修多个课程，一个课程也可以被多个学生选修，课程还有字段保存任课老师...如此复杂的业务，必然要掌握连接查询才能实现。

#### 创建多表

按照数据的关联数量分，多表主要有以下三种关系：

- 多对一(一对多)关系：即A表的数据只能关联B表的一条数据，但B表的一条数据能关联多条A表的数据，比如学生(A)与学院(B)；

- 多对多关系：即A表的数据可以关联B表的多条数据，B表的多数据也能关联多条A表的数据，比如学生(A)和课程(B)；

    多对多的关系通常需要使用一个中间表来连接两个表。比如学生(A)和课程(B)，那我们再定义一个选课表(C)，C表中只有两个字段：学生id和课程id，当一个学生选了多个课时，就可以在C表中插入对应的数据。在C表中查询某个学生可以得出这个学生选的课，查询某个课程也可以得出这个课程有哪些学生。
- 一对一关系：即A表的数据只能关联B表的一条数据，B表的一条数据也只能关联一条A表的数据，这种情况多见于横向拆表，把一个表拆成两个部分，其中一个表存放的是经常访问的数据，另一个表存放不经常访问的数据。两个表的每条数据都一一对应。这样做可以提高查表时的效率；



##### 创建业务案例

接下来我们就以上文中提到的师生信息数据库为例，创建一个数据库。在创建数据库和定义多表时，我们**不一定要使用前面所讲的外键约束**。我们也可以不使用外键约束，不过这样难以保证数据的正确性。

- 创建数据库：

```
CREATE DATABASE IF NOT EXISTS Information DEFAULT CHARSET utf8mb4;
USE Information;
```

- 创建学院表：

```
CREATE TABLE college(
	id INT UNSIGNED UNIQUE NOT NULL COMMENT '学院id',
	name char(20) NOT NULL COMMENT '学院名',
	teacher_num INT UNSIGNED COMMENT '学院教师人数',
	student_num INT UNSIGNED COMMENT '学院学生人数'
)COMMENT '学院表';
```

插入数据：

```
INSERT INTO college VALUES (1,'计算机科学学院',2,5);
INSERT INTO college VALUES (2,'数学学院',3,6);
INSERT INTO college VALUES (3,'人文学院',1,3);
```

- 创建老师表：

```
CREATE TABLE teacher(
	id INT UNSIGNED UNIQUE NOT NULL COMMENT '教师id',
	name char(20) NOT NULL COMMENT '教师名',
	college_id INT UNSIGNED COMMENT '教师所在学院',
	salary INT UNSIGNED COMMENT '教师薪资',
	leader INT UNSIGNED COMMENT '领导'
)COMMENT '教师表';
```

插入数据：

```
INSERT INTO teacher VALUES (1,'陈老师',1,3000,NULL);
INSERT INTO teacher VALUES (2,'王老师',1,4000,1);
INSERT INTO teacher VALUES (3,'李老师',2,5000,NULL);
INSERT INTO teacher VALUES (4,'赵老师',2,6000,2);
INSERT INTO teacher VALUES (5,'张老师',2,7000,2);
INSERT INTO teacher VALUES (6,'周老师',3,8000,NULL);
INSERT INTO teacher VALUES (7,'吴老师',NULL,9000,NULL);
```

- 创建学生表：

```
CREATE TABLE student(
	id INT UNSIGNED UNIQUE NOT NULL COMMENT '学生id',
	name char(10) NOT NULL COMMENT '学生名',
	gender char(1) NOT NULL COMMENT '性别',
	class char(10) COMMENT '学生所在班级',
	college_id INT UNSIGNED COMMENT '学生所在学院',
	tuition INT UNSIGNED COMMENT '学费',
	headmaster INT UNSIGNED COMMENT '班主任'
)COMMENT '学生表';
```

插入数据：

```
INSERT INTO student VALUES (1,'张三','男','软件1',1,3500,1),
						   (2,'李四','男','软件1',1,3600,1),
						   (3,'王五','男','软件1',1,3700,1),
						   (4,'马六','女','软件2',1,3800,2),
						   (5,'朱七','男','网工1',1,3900,2),
						   (6,'路人甲','男','数科1',2,4000,3),
						   (7,'路人乙','女','数科1',2,4100,3),
						   (8,'路人丙','男','数科1',2,4200,3),
						   (9,'路人丁','男','数科1',2,4300,3),
						   (10,'路人戊','男','数科2',2,4400,4),
						   (11,'路人己','女','数科2',2,4500,4),
						   (12,'路人庚','女','人文1',3,4600,6),
						   (13,'路人辛','女','人文1',3,4700,6),
						   (14,'路人壬','女','人文1',3,4800,6),
						   (15,'张三丰','男',NULL,NULL,4900,NULL);
```

- 创建课程表：

```
CREATE TABLE curriculum(
	id INT UNSIGNED UNIQUE NOT NULL COMMENT '课程id',
	name char(20) NOT NULL COMMENT '课程名',
	period INT UNSIGNED NOT NULL COMMENT '课时',
	teacher INT UNSIGNED COMMENT '任课老师id'
)COMMENT '课程表';
```

插入数据：

```
INSERT INTO curriculum VALUES (1,'高等数学',48,3);
INSERT INTO curriculum VALUES (2,'线性代数',36,4);
INSERT INTO curriculum VALUES (3,'近代史',36,6);
INSERT INTO curriculum VALUES (4,'计算机组成原理',56,1);
INSERT INTO curriculum VALUES (5,'C语言程序设计',48,2);
```

因为学生和课程是多对多的关系，还要创建一个额外的选课表来保存学生选了那些课。

- 创建选课表：

```
CREATE TABLE curricula_variable(
	s_id INT UNSIGNED NOT NULL COMMENT '学生id',
	c_id INT UNSIGNED NOT NULL COMMENT '课程id'
)COMMENT '选课表';
```

插入数据：

```
INSERT INTO curricula_variable VALUES(1,1),(1,2),(1,3),(1,4),(1,5),(2,2),(2,3),(2,5),(3,1),(3,5),(4,2),(5,1),(5,3),(5,5),(7,2),(7,5),(8,3),(9,3),(10,1),(10,2),(10,3),(10,5),(11,2),(11,3),(11,5),(12,3),(12,4),(13,4);
```



#### 多表连接查询

多表连接查询是指我们同时需要输出两个表中的字段时，就需要结合两张表进行查询。

##### 多表连接类型

根据数据的字段对应分类，连接有以下几种分类：

- 交叉连接：就是笛卡尔乘积

- 内连接：查询两个表中交集的部分
    - 等值连接：当一个表中的字段对应着另一个表的字段
    - 非等值连接：当一个表中的字段与另一个表的字段有非相等的关系，比如范围
    - 自连接：当一个表中的某字段对应着自己的另一个字段
- 外连接：查询两个表中交集+任意表中的部分，外连接的目的是让某个表中那些没有和另一个表有对应关系的数据也能被输出
    - 右外连接：查询两个表中交集+左表中的部分
    - 左外连接：查询两个表中交集+右表中的部分
    - 全外连接：查询两个表中交集+左表中的部分+右表中的部分

##### 连接查询语法

在sql92标准中，多表的查询和单表的查询语法很相似：

```
SELECT 字段列表 FROM 表列表 条件/分组/排序...;
```

因为sql92标准只支持内连接类型的多表查询，因此WHERE条件在大多数情况下都可以充当连接条件。随着sql语言的发展，出现了外连接的需求，于是在sql99标准中，又添加了以下语法用于链接多表查询：

```
-- 如果是内连接，还可以使用显示内连接俩表的语法：
SELECT 字段列表 FROM 表1 [INNER] JOIN 表2 ON 连接条件 条件/分组/排序...;
-- 如果是左/右外连接，可以使用：
SELECT 字段列表 FROM 表1 LEFT/RIGHT [OUTER] JOIN 表2 ON 连接条件 条件/分组/排序...;
-- 如果是全外连接，可以使用(!!!MySQL不支持!!!)
SELECT 字段列表 FROM 表1 FULL [OUTER] JOIN 表2 ON 连接条件 条件/分组/排序...;
```

sql99标准的多表查询语法更为全面强大。它将连接条件和WHERE条件分开了，连接条件专用于筛选两个表的对应数据，WHERE条件则专注于筛选用户想要的数据。连接条件和WHERE条件之间不使用逻辑运算符连接，但他们的功能是相同的，你完全可以把连接条件放在WHERE条件里。

在未添加限定连接条件的情况下，多表查询会出现**笛卡尔乘积**。笛卡尔乘积是多表查询的基础。前面我们讲过DQL语句的执行顺序，笛卡尔乘积可以看作是在执行连接条件前的结果集，连接条件的执行只是在对笛卡尔乘积进行判断并消减。

如查询老师与学院：

a.不添加限定条件

```
SELECT teacher.name,college.name FROM teacher,college;
-- sql99
SELECT teacher.name,college.name FROM teacher INNER JOIN college;
```

![image-20220908105016963](http://md.ruimix.top/md/image-20220908105016963.png)

可以看见出现了老师数量7 × 学院数量3 = 21条数据，这就是笛卡尔乘积。这显然不是我们想要的。

b.添加限定条件，我们可以限定：在笛卡尔乘积中，只有老师的学院id和学院id对应(相等)的数据才会保留，此时输出就正常了

```
SELECT teacher.name,college.name FROM teacher,college WHERE teacher.college_id = college.id;
-- sql99
SELECT teacher.name,college.name FROM teacher INNER JOIN college ON teacher.college_id = college.id;
```

![image-20220908105040838](http://md.ruimix.top/md/image-20220908105040838.png)

因为吴老师不属于表中三个学院，故未在此显示出。要显示出来，需要使用外连接。



##### 内连接查询

###### 1.等值连接

当一个表中的字段对应着另一个表的字段时，我们可以使用等值连接。比如上例中的查询老师所在哪个学院就是等值连接，在笛卡尔乘积中，当老师所在的学院id和学院id相等时才会被筛选出来输出。



###### 2.非等值连接

当一个表中的字段与另一个表的字段有非相等的关系，比如范围(我们可以用BETWEEN...AND...)，取值(IN(...))...总之表和表数据之间的关系不再是等于了。接下来举个例子。

创建一个学费分段表：

```
CREATE TABLE tuition_level(
	id INT UNSIGNED UNIQUE NOT NULL COMMENT '等级id',
	name char(5) NOT NULL COMMENT '等级',
	low INT UNSIGNED NOT NULL COMMENT '最低学费',
	high INT UNSIGNED NOT NULL COMMENT '最高学费'
)COMMENT '学费分段表';
```

插入数据：

```
INSERT INTO tuition_level VALUES (1,'2千级',2000,2999),
							  	 (2,'3千级',3000,3999),
							  	 (3,'4千级',4000,4999),
							  	 (4,'5千级',5000,5999);
```

接下来我要查询每个学生的学费等级，字段为学生姓名和学费等级

```
SELECT student.name,tuition_level.name FROM student,tuition_level WHERE student.tuition BETWEEN tuition_level.low AND tuition_level.high;
-- sql99
SELECT student.name,tuition_level.name FROM student INNER JOIN tuition_level ON student.tuition BETWEEN tuition_level.low AND tuition_level.high;
```

结果如下：![image-20220908111930967](http://md.ruimix.top/md/image-20220908111930967.png)



###### 3.自连接

自连接指在一个表中数据的一个字段对应另一个数据的其他字段。比如老师表的领导字段指向的是老师表的id字段。在使用自连接时，需要填写两个相同的表名。**为了区分这两个相同的表名，我们必须为表名重命名**。

比如查询各位老师的领导时，必须使用两此teacher表，为了区分主从关系，我们需要重命名为t1、t2：

```
SELECT t1.name,t2.name FROM teacher AS t1,teacher AS t2 WHERE t1.leader = t2.id;
-- sql99
SELECT t1.name,t2.name FROM teacher AS t1 INNER JOIN teacher AS t2 ON t1.leader = t2.id;
```

结果如下：![image-20220908113203821](http://md.ruimix.top/md/image-20220908113203821.png)



##### 外连接查询

外连接的主要作用是让某一张表中没有关联另一张表的数据也可以输出。我们在数据库中插入了学院信息为空的吴老师，以及班主任信息为空的张三丰同学。在进行输出每个同学的班主任时，如果是使用内连接，吴老师和未当班主任的老师就不会输出，没有指定班主任的张三丰同学也不会输出。如下：

```
SELECT S.name,T.name FROM student AS S INNER JOIN teacher AS T ON S.headmaster = T.id;
```

![image-20220908133711968](http://md.ruimix.top/md/image-20220908133711968.png)

这时候就可以使用外连接。下面就以学生-班主任表为例，进行三种外连接查询的示范。

###### 左外连接

输出交集信息+左表(学生表)中的全部信息

```
SELECT S.name,T.name FROM student AS S LEFT OUTER JOIN teacher AS T ON S.headmaster = T.id;
```

可以看到学生表中所有同学都被输出了，包括没有班主任的张三丰

![image-20220908133754870](http://md.ruimix.top/md/image-20220908133754870.png)



###### 右外连接

输出交集信息+右表(老师表)中的全部信息

```
SELECT S.name,T.name FROM student AS S RIGHT OUTER JOIN teacher AS T ON S.headmaster = T.id;
```

可以看到老师表中所有的老师都被输出了，包括未当班主任的张老师和吴老师

![image-20220908134031170](http://md.ruimix.top/md/image-20220908134031170.png)



###### 全外连接

输出交集信息+左表(学生表)中的全部信息+右表(老师表)中的全部信息

```
SELECT S.name,T.name FROM student AS S FULL OUTER JOIN teacher AS T ON S.headmaster = T.id;
```

由于MySQL不支持，这里就不运行了。



#### 多表子表查询

还有一种查询方式也需要运用到多表。当我们把数据分开存放到多个表时，如果要使用一个表的查询结果作为条件去查询另一个表，需要多步进行查询：先查询一张表，并记录结果，再将结果作为条件去查另一张表...这样非常繁琐。SQL中可以嵌套使用查询结果来解决这个问题。

根据子表返回的结果，可以分成四种：

1. 标量子查询：子表返回的是一个值

```
父语句 WHERE 父语句的某字段 = (子查询语句);
```



2. 列子查询：子表返回的是一个字段的值，可以有多行

```
父语句 WHERE 父语句的某字段 操作符 (子查询语句);
```

常用的操作符有以下几种：

|  操作符  |                      描述                      |
| :------: | :--------------------------------------------: |
|    IN    |               在集合内多选一满足               |
|  NOT IN  |                   不在集合内                   |
| ANY/SOME | 返回集合内的一个任意值，必须搭配关系运算符使用 |
|   ALL    |     集合内的所有值，必须搭配关系运算符使用     |



3. 行子查询：子表返回的是一条数据，数据可以有多列

```
父语句 WHERE (父语句的字段列表) 操作符 (子查询语句);
```

常用的操作符有以下几种：

| 操作符 |        描述        |
| :----: | :----------------: |
|   IN   | 在集合内多选一满足 |
| NOT IN |     不在集合内     |
|   =    |     与数据匹配     |
|   <>   |    与数据不匹配    |

**条件中父语句的字段列表必须和子查询语句返回的字段列表一致**



4. 表子查询：子表返回的是一个结果集

```
父语句 WHERE (父语句的字段列表) IN/NOT IN (子查询语句);
```

因为子语句返回的是一个结果集，也可以在子语句的结果集上再进行父语句的操作：

```
父语句 FROM (子查询语句) 条件...;
```



细节：

- 其中父语句不一定是DQL语句，也可以是其他语句。
- 嵌套可以使用多次
- 行子查询可以看作是表子查询的特殊情况



#### 联合查询UNION

联合查询就是把多次查询的结果合并起来，形成一个新的查询结果集。语法为

```
查询语句1
UNION [ALL]
查询语句2;
```

添加ALL会将所有结果都进行拼接并直接输出，不添加会使拼接后进行去重。

和DISTINCT不同的是，DISTINCT是针对单条查询语句的结果集，而ALL参数是针对拼接后的结果集。

**值得注意的是，并非所有语句的结果集都能使用UNION拼接，只有结果集的字段列表相同时才能够进行拼接。**

举例：查询学生表中李老师的学生信息和选了高数课的学生信息，并一起输出。

```
SELECT * FROM student WHERE headmaster = (SELECT id FROM teacher WHERE NAME = '李老师');
UNION ALL
SELECT * FROM student WHERE id IN 
	(SELECT s_id FROM curricula_variable WHERE c_id = (
		SELECT id FROM curriculum WHERE NAME = '高等数学'));
```



## MySQL事务

在MySQL中，我们常常会有以下业务场景：

当我们使用MySQL来保存用户的游戏信息时，比如点券、金币和体力，会希望“捆绑”几条语句：比如在游戏对局结算时，我们需要根据对局内的数据来修改玩家信息：增加玩家的金币啦、根据玩家对局内使用的道具来扣掉玩家的点券啦、对局结束要减少玩家的体力啦...我们希望这些语句是捆绑起来进行的，如果不捆绑起来，当玩家在结算时遇到了程序崩溃，就可能导致其中的某些语句未执行，这会导致数据不准确。

在MySQL中，这个“捆绑”的功能，就是MySQL事务。**MySQL事务只有在使用InnoDB引擎时才能够使用。**根据以上案例，我们可以知道事务可以把多条SQL语句捆绑起来执行。一旦开始执行，就必须执行完所有捆绑起来的语句；当其中一条执行不成功时，就会执行回滚操作，回滚操作会将数据恢复到执行所有捆绑语句之前，就像没有任何事情发生过一样。

MySQL事务由以下四个特性，称为**ACID**：原子性（**A**tomicity，或称不可分割性）、一致性（**C**onsistency）、隔离性（**I**solation，又称独立性）、持久性（**D**urability）。

- **原子性：**一个事务（transaction）中的所有操作，要么全部完成，要么全部不完成，不会结束在中间某个环节。事务在执行过程中发生错误，会被回滚（Rollback）到事务开始前的状态，就像这个事务从来没有执行过一样。
- **一致性：**在事务开始之前和事务结束以后，数据库的完整性没有被破坏。这表示写入的资料必须完全符合所有的预设规则，这包含资料的精确度、串联性以及后续数据库可以自发性地完成预定的工作。
- **隔离性：**数据库允许多个并发事务同时对其数据进行读写和修改的能力，隔离性可以防止多个事务并发执行时由于交叉执行而导致数据的不一致。事务隔离分为不同级别，包括读未提交（Read uncommitted）、读提交（read committed）、可重复读（repeatable read）和串行化（Serializable）。
- **持久性：**事务处理结束后，对数据的修改就是永久的，即便系统故障也不会丢失。

**事务并不是简单地把多条语句打包起来同一执行，而是尝试执行其中的语句，直到提交，执行结果才会被写死。**这有点类似于我要做一道题，我先把解题思路用铅笔写，我们可以随时回滚(擦除)，当提交时，我们就确认了答案，而且使用墨笔描黑，不能再进行撤销。当然这个比喻可能不太恰当，而且不同的隔离性也有不同的操作。但是要切记MySQL事务是同步执行的。



### 使用事务

在使用事务之前，我们要了解MySQL中对事务的配置，我们可以使用这条语句来查看事务的配置。状态1为打开自动提交，这个状态下，每一条SQL执行完之后都会被自动提交，状态0为关闭，这个状态下执行的SQL语句只有我们手动提交才会真正地生效。

```
SELECT @@AUTOCOMMIT;
```

我们可以通过如下语句来修改这个配置

```
SET AUTOCOMMIT=0; 禁止自动提交
SET AUTOCOMMIT=1; 开启自动提交
```

- 当关闭自动提交时，我们需要使用`COMMIT;`来提交SQL语句，如果想回滚，则使用`ROLLBACK;`来撤销所有未进行提交的修改。

- 当开启自动提交时，我们仍然可以使用事务。不过这时候我们需要手动声明一下事务。使用`START TRANSACTION;`或`BEGIN;` 来开启一个事务，使用`COMMIT;`来结束当前事务。如下

    ```
    START TRANSACTION;
    ...
    todo
    ...
    COMMIT;
    ```

    同样地，如果想回滚，则使用`ROLLBACK;`来撤销所有未进行提交的修改。

除此之外，我们还可以对事务进行断点：

```
SAVEPOINT identifier; --允许在事务中创建一个保存点，一个事务中可以有多个 SAVEPOINT;
RELEASE SAVEPOINT identifier; 删除一个事务的保存点，当没有指定的保存点时，执行该语句会抛出一个异常;
ROLLBACK TO identifier 把事务回滚到标记点,在断点之后的修改会被撤销;
```

**注意的是，如果通过命令行来操作MySQL，当前窗口开启的事务只在当前窗口中生效！**



### 事务并发隔离

如果我们开启自动提交，我们完全不用担心数据的稳定性，因为单条语句在数据库内部是串行执行的。

如果我们串行地使用有多条语句的事务时，那么我们也不用担心数据的稳定性，因为数据在一个时刻只能被一个事务访问。

但是如果我们并行地使用事务，就会出现问题了：多个事务有可能会抢着读写同一个数据。出现的情况有以下四种：

1. 脏读：事务读取到了其他事务为提交的数据。比如事务A对一个int类型、初始值为100的值进行操作。事务A试图将值加50，在A执行完加操作之后，前面我们讲过事务并不是简单地打包，而是同步进行的，此时表中的值为150，这时事务B也插手进来对值进行操作，试图将值加30，因为B读取到的值是150，所以此时事务B认为最终结果为180。而最后事务A发生了某些错误回滚了，事务B又成功地提交了，就会导致最终结果不准确。这是因为事务B读取到了事务A未进行提交的脏数据导致的。
2. 不可重复读：事务在对数据进行查询时，发现数据被其他事务修改了。比如在事务A要读取两次初始值为100的值，在开始读到的值是100，之后事务A根据读取到的值去执行其他语句了，此时事务B迅速地将值修改为了150。事务A第二次读到的值是150，那事务A究竟应该取哪一个值呢？事务A根据读取到的值去执行的其他语句是否是过时的呢？事务A是否要进行回滚呢？
3. 幻读：事务在对数据进行查询时，发现原来不存在的数据被其他事务添加了。比如在事务A要插入一个数据，在寻找插入位置时找到了空位n，之后事务A就准备插入数据了，此时事务B在空位n处插入了“李四”。事务A插入的时候发现位置n已经不为空了，那事务A究极要把数据插入到哪儿呢？

为了解决这些问题，InnoDB引擎为我们提供了四个隔离级别来解决这些问题

|               隔离级别               | 脏读 | 不可重复读 | 幻读 |
| :----------------------------------: | :--: | :--------: | :--: |
| 允许读未提交的数据(READ UNCOMMITTED) |  ×   |     ×      |  ×   |
| 只允许读已提交的数据(READ COMMITTED) |  〇  |     ×      |  ×   |
| 可重复读(REPEATABLE READ)(**默认**)  |  〇  |     〇     |  ×   |
|       可串行化 (SERIALIZABLE)        |  〇  |     〇     |  〇  |

我们可以使用这条语句来查看当前事务的隔离级别：

```
SELECT @@TRANSACTION_ISOLATION;
```

--设置事务隔离级别设置事务隔离级别：

```
SET[SESSION| GLOBAL] TRANSACTION ISOLATION LEVEL {READUNCOMMITED | READ COMMITTED |REPEATABLE READ| SERALIZABLE}
```



## MySQL性能分析

在使用MySQL时，我们往往希望数据库的执行能力更高，反应更快。然而现实往往并不是我们想要的那样。所以我们需要对MySQL进行优化。

进行优化得有个根据呀，至少得知道哪里需要优化。那我们根据MySQL性能分析就能做到了。

#### SQL语句执行频率分析

```
SHOW GLOBAL STATUS LIKE 'Com_______';  -- Com后面加7个下划线
```

我们可以通过这样一条语句来查看当前数据库的SQL语句执行计数情况，我们可以根据这个数据来得出当前数据库主要用来干什么。如果查询的计数占主要，那么我们就应该对查询操作进行优化，如果修改的次数寥寥无几，那么花时间精力去优化修改是没有收益的。



#### 查询慢日志

慢查询日志是MySQL提供的，默认是关闭的。它可以用来记录执行时间超过一定值的语句。默认阈值是10秒，当然我们可以手动指定这个时间。

开启慢查询日志功能需要修改MySQL的配置文件`/etc/my.cnf`，假如下列参数：

```
#开启MySQL慢日志查询开关
slow_query_log=1
#设置慢日志的时间为5秒，SQL语句执行时间超过5秒，就会视为慢查询，记录慢查询日志
long_query_time=5
```

更改之后需要重启MySQL才能生效。

开启之后，慢日志将会保存至`/var/lib/mysql/localhost-slow.log`里。



#### Profile详情

上文中提到的MySQL慢日志只能记录时间超过阈值的操作，但实际开发中，我们也需要对那些查询速度没有超过阈值的、速度临近阈值的语句进行优化。如何得出这些语句的执行详情呢？MySQL中也提供了相关功能，但是这个功能根据版本而进行支持，且是默认关闭的。

查询当前数据库是否支持Profile操作，如果为YES，则为支持。

```
SELECT @@have_profiling;
```

查询当前Profile详情开启情况，0表示未开启，1表示已开启。

```
SELECT @@profiling;
```

开启/关闭Profile详情

```
SET profiling = 1/0;
```

开启后，我们就可以执行一系列的语句了。在执行完语句之后，我们可以使用如下语句来查看已执行语句的耗时详情。

```
-- 查看每一条SQL的耗时基本情况，会提供query_id用于进一步查询
show profiles;
-- 查看指定query_id的SQL语句各个阶段的耗时情况
show profile for query query_id;
-- 查看指定query_id的SQL语句CPU的使用情况
show profile cpu for query query_id;
```



#### Explain执行计划

上文中提到的性能分析，都是针对多条语句的，对单条语句只能显示该条数据的耗时。然而只知道时间是不能用来优化的，我们还需要知道语句在执行时的详细参数才能进行优化。在使用数据库的过程中，查询的操作往往是最多的。MySQL专门设计了一个关键字`explain`或`desc`用于查看查询语句的具体参数：

```
EXPLAIN SELECT语句;
```

其中后面的SELECT语句按照我们实际用的来就好。加上这个关键字后，会返回一个含有该条SELECT语句的具体参数表。这个参数表有以下字段组成：

| 字段          | 描述                                                         |
| ------------- | ------------------------------------------------------------ |
| id            | 在子查询和多表查询时用到表的顺序，id越大越先执行，id相同按顺序执行。 |
| select_type   | 代表查询的类型，比如不查询多表的简单查询SIMPLE、查询多表时的主查询PRIMARY、联合查询UNION、包含子查询的SUBQUERY等。 |
| table         | 展示数据来自哪一张表。                                       |
| partitions    | 展示数据来自哪一个分区。                                     |
| type          | 表示连接类型，有NULL/system/const/eq_ref/ref/range/index/all。其中性能由前往后降低。NULL表示不查询任何表，all表示遍历表。<br/>**system**：查询系统表<br/>**const**：使用主键或者唯一索引作为条件查询时<br/>**eq_ref**：多表查询在连接时使用了唯一和主键索引。<br/>**ref**：多表查询中在连接时没有使用唯一和主键索引。<br/>**range**：通常是范围扫描，如使用了>、<等范围查询条件。<br/>**index**：虽然用了索引，但是也会遍历扫描索引。<br/>**一般来说，好的sql查询至少达到range级别，最好能达到ref**。 |
| possible_keys | 可能用到的索引。                                             |
| key           | 实际用到的索引。                                             |
| key_len       | 用到索引的关键字长度。                                       |
| ref           | 显示索引的哪一列被使用了，如果可能的话，是一个常数。哪些列或常量被用于查找索引列上的值 |
| rows          | MySQL认为至少要查询几行才能得出结果。在InnoDB中可能为估计值  |
| filtered      | 表示返回的结果和查询的行数的百分比。值越大表示查询越高效。   |
| Extra         | 不适合在其他字段中显示，但是十分重要的额外信息。             |



## MySQL索引

索引(Index)是一种高效查找数据的、有序的数据结构，使用索引可以让DQL语句执行地更快，相当于是对DQL的优化。在MySQL的默认引擎InnoDB中，索引维护了一棵B+树。索引能对SELECT查询语句进行性能上的优化，减少查询耗时和磁盘IO，因为**没有使用到索引的查询使用的是全表扫描**。索引好用，但其有一个代价就是牺牲了磁盘空间，因为B+树的叶子节点和分支节点都保存了数据，相当于冗余。

> MySQL中，B+树的每一个节点在磁盘中表现为一个页。而MySQL中一个页最大只能有16KB大小。在MySQL中一个指针占6个字节，假设使用类型为int的字段(4字节)作为主键建立索引，因为指针总是比键的数量多一个，那么根节点最多就能分出
> $$
> 16 × 1024 = n × 4 + (n + 1) ×6
> $$
> 解得n = 1637个指针，也就是索引的B+树的度最大为1637。（当然这个值会根据字段的类型大小而变化）
>
> 如果深度为m，那么最多可以分出n^m^个指针，也就是指向n^m^个页。假设每个页可以存储k条数据，那么这棵B+树就可以存储n^m^×k条数据，只要几层就足以存下数量级比较小的数据。

索引是在表中针对字段建立的，对不同字段可以建立不同索引，对相同字段也可以建立不同的索引，甚至可以对多个字段建立索引，这是很自由的，这让程序猿们可以根据实际的业务需求来建立合适的索引。



#### 索引的分类

- **在InnoDB存储引擎中，根据索引的存储形式，可以分为以下两种：**

    - 聚集索引，**聚集索引必须有且仅有一个。**MySQL会选择主键作为聚集索引，如果没有主键，选择第一个唯一字段作为聚集索引，如果没有唯一字段，MySQL会创建一个隐藏的rowid作为聚集索引。**聚集索引的每个节点的数据区都存放了一整条的数据。**
    - 二级索引，二级索引是针对其他字段的索引，可以有多个。与聚集索引不同的是，**二级索引的数据区保存的是聚集索引的键值。**也就是说，在使用二级索引进行索引操作时，会先进行二级索引，拿到键值结果后再使用该键值聚集索引进行索引，最终得到结果。这一过程也称为**回表查询。**

    因为回表查询要索引两次，所以二次索引要比聚集索引慢上许多。所以我们在进行索引的时候，尽量避免回表查询。

- **根据包含字段的数量分可分为单列索引和联合索引。**
    - 单列索引每个索引只针对一个字段，非聚集索引的单列索引的B+树的节点只保存字段值和主键值；
    - 联合索引每个索引包含多个字段，联合索引可以组合创建，甚至字段的顺序不一样，创建的索引也不一样。如果业务存在多个字段的查询，就建议使用联合索引。非聚集索引的联合索引的B+树的节点按照创建索引时的字段顺序存储了字段值。

- **根据字段的属性分可分为以下四个索引：**
    - 主键索引：PRIMARY，针对表中的主键自动创建，只能有一个
    - 唯一索引：UNIQUE，针对为没有重复值的字段
    - 常规索引：默认创建的索引
    - 全文索引：FULLTEXT，该索引查找的是文本中的关键词，比如纯英文的文献，我们可以将每个单词后面跟一串文本的id，这样在检索该词时，立马就能得出包含该词的文档。这个技术也成为倒排。



#### 创建索引

前面我们已经说过了索引是针对字段建立的，下文将会介绍索引的语法。

- 创建索引

    ```
    CREATE [UNIQUE|FULLTEXT] INDEX 索引名称 ON 表名(字段列表);
    ```

    其中索引名称有规范，格式为`idx_表名_字段名`，如果索引有多个字段，则命名可以为`idx_表名_字段1_字段2_...`。这样的命名规范可以让人很明了地使用索引。

    如果要对多个字段创建联合索引，可以使用字段列表。**最好将联合索引中字段列表中索引的最多的、最重要的字段要放在最前面**，因为添加之后使用该索引需要遵循最左前缀原则(下文会介绍)。

- 查看表中存在的索引

    ```
    SHOw INDEX FROM 表名;
    ```

- 删除索引

    ```
    DROP INDEX 索引名称 ON 表名;
    ```

- 创建前缀索引

    当我们有字段的类型长度非常长时，比如存入的类型是字符串，且内容为长度为40的一段SHA256哈希值。当我们使用索引的时候，每次匹配都会对照40个字符。而我们知道SHA256哈希值其实重复率很低，我们能否每次只匹配39个字符即可得出对应的结果呢？那38个呢？...这时候就应该使用前缀索引了。前缀索引能够将字段的前n个字符当作键值构建索引，这样节省了空间，降低了磁盘IO。

    ```
    CREATE [UNIQUE|FULLTEXT] INDEX 索引名称 ON 表名(字段(n));
    ```

    前缀索引和普通索引的语法很相似，只不过在字段后面加了个参数n来表示要选取前几个字符。
    
    那么，前缀字符数量n到底要取多少才合适呢？如果取1，那么只选取一个字符，重复率就会很高；如果取39，虽然可以保证大多数情况下不会发生重复，但意义不大。为此，我们定义了一个比率：选择性=索引中前n个字符对比数据的不重复数量/数据的总量。选择性越高越好。比如唯一索引中的选择性就为1，因为所有数据都是不重复的。选择性不为1也没有关系，MySQL会自动对重复的值进行再匹配，但是这样要消耗性能，所以我们应该尽量让选择性趋近1。
    
    
    
    我们可以逐渐降低n的值，并算出n对应的选择性，最后再进行筛选。
    
    索引中前n个字符对比数据的不重复数量：截取前n个字符进行筛选
    
    ```
    SELECT count(distinct substring(email,1,n)) FROM 表名;
    ```
    
    数据的总量：
    
    ```
    SELECT count(*) FROM 表名;
    ```
    
    将这两项的结果相除，即可得到选择性。
    
- 创建自定义顺序的索引

    索引默认是根据字段值进行升序排序的，我们可以根据自己的需求去创建其他顺序的索引。只需要在每一个字段后面加上asc(升序，默认)或desc(降序)即可。创建自定义顺序的索引主要是为了后续的ORDER BY优化。

    ```
    CREATE [UNIQUE|FULLTEXT] INDEX 索引名称 ON 表名(字段1 [asc/desc],字段2 [asc/desc]...);
    ```

    



##### 创建索引时的一些原则

1. 针对于数据量较大，且查询比较频繁的表建立索引。
2. 针对于常作为查询条件（where)、排序（order by)、分组(group by)操作的字段建立索引。
3. 尽量选择区务度高的列作为索引，尽量建立唯一索引，区分度越高，使用索引的效率越高。
4. 如果是字符串类型的字段，字段的长度较长，可以针对于字段的特点，建立前缀索引。
5. 尽量使用联合索引，减少单列索引，查询时，联合索引很多时候可以覆盖索引，节省存储空间，避免回表，提高查询效率。
6. 要控制索引的数量，索引并不是多多益善，索引越多，维护索引结构的代价也就越大，会影响增删改的效率。
7. 如果索引列不能存储NULL值，请在创建表时使用NOTNULL约束它。当优化器知道每列是否包含NULL值时，它可以更好地确定哪个索引最有效地用于查询。



#### 索引的使用

使用索引可以大大减少查找时间。但是如果不按索引的使用规则来查询，就相当于没有用到索引，或者用了也白用。那么接下来我们来介绍索引的使用规则。

在介绍索引的使用规则之前，假设我们有一张学生表，以此为例。

```
CREATE TABLE student(
	id INT UNSIGNED PRIMARY KEY NOT NULL COMMENT '学生id',
	name char(10) NOT NULL COMMENT '学生名',
	gender char(1) NOT NULL COMMENT '性别',
	class char(10) COMMENT '学生所在班级',
	college_id INT UNSIGNED COMMENT '学生所在学院',
	tuition INT UNSIGNED COMMENT '学费',
)COMMENT '学生表';
```

学生表的字段：

|    字段    |     类型     |    约束     |     描述     |
| :--------: | :----------: | :---------: | :----------: |
|     id     | INT UNSIGNED | PRIMARY KEY |    学生id    |
|    name    |   char(10)   |  NOT NULL   |    学生名    |
|   gender   |   char(1)    |  NOT NULL   |     性别     |
|   class    |   char(10)   |      -      | 学生所在班级 |
| college_id | INT UNSIGNED |      -      | 学生所在学院 |
|  tuition   | INT UNSIGNED |      -      |     学费     |

接下来我们来创建索引。

id是主键约束，因此MySQL会自动为其创建一个主键索引(聚集索引)。

对姓名创建一个单列索引：

```
CREATE INDEX idx_student_name ON student(name);
```

对班级、学院和学费创建一个联合索引：

```
CREATE INDEX idx_student_class_college_id ON student(class,college_id,tuition);
```



#### 索引的使用原则

- 最左前缀原则1

    在使用联合索引时，要遵守最左前缀原则1。最左前缀原则1指的是查询条件要从索引的最左列开始包含条件，并且不跳过索引中的列。如果跳跃某一列，索引将部分失效(后面的字段索引失效)。

    比如查询学生的班、学院、学费信息时，使用这条语句可以完整地使用该联合索引

    ```
    SELECT name FROM student WHERE class = 'xx' AND college_id = x AND tuition = xxxx;
    ```

    如果跳过了某个字段，跳过的字段之前的字段可以使用索引，跳过的字段之后的字段则不能使用索引：

    ```
    SELECT name FROM student WHERE class = 'xx' AND tuition = xxxx;
    ```

    跳过了学院字段，导致班级可以使用索引，而学费不能使用。

    **提示**：最左前缀原则只是对条件的内容进行限定，条件的顺序是没有限制的。只要索引的相关字段存在且符合法则就会使用索引。比如我把班级查询放到最后面也可以完整地使用索引。

    ```
    SELECT name FROM student WHERE college_id = x AND tuition = xxxx AND class = 'xx';
    ```

- 最左前缀原则2

    在使用联合索引进行范围查找时，要遵守最左前缀原则2。最左前原则2则指的是当某一列使用范围查找时，索引将部分失效(后面的字段索引失效)。这里的范围只限于＞和＜。

    比如查询学生的班、学院、学费信息时我对学院字段用了大于号，则学院字段之后(不包括学院字段在内)，将导致学费信息不能走索引：

    ```
    SELECT name FROM student WHERE class = 'xx' AND college_id > x AND tuition = xxxx;
    ```

    **提示**：范围查询只针对＞和＜。用＞＝或＜＝是不会导致索引失效的。

- 函数失效原则

    当我们使用有索引的字段进行函数运算时，索引将会失效。比如

    ```
    -- 可以使用索引
    SELECT name FROM student WHERE name = 'xx'; 
    -- 在索引的相关字段上上使用了函数，索引失效
    SELECT name FROM student WHERE SUBSTRING(name,0,1) = '张'; 
    ```

- 类型匹配原则

    当使用索引时必须严格匹配索引相关字段的类型。如果类型不匹配，MySQL会对我们的类型进行转换，一旦转换则索引将失效。最常见的错误为字符串未加单引号。

    ```
    -- 可以使用索引
    SELECT name FROM student WHERE name = 'xx'; 
    -- 索引的字符串字段未加引号，索引失效
    SELECT name FROM student WHERE name = xx; 
    ```

- 模糊匹配原则

    当我们使用模糊匹配时，尾部存在模糊匹配依然可以使用索引，头部存在模糊匹配则会导致索引失效。

    ```
    -- 尾部存在模糊匹配，可以使用索引
    SELECT name FROM student WHERE name = '张%'; 
    -- 头部存在模糊匹配，索引失效
    SELECT name FROM student WHERE name = '%小龙'; 
    ```

- 条件或原则

    当我们的条件中，出现了或逻辑运算符(OR)，只要出现了没有索引的字段，所有索引都会失效。

    ```
    -- or条件字段都有索引，可以使用索引
    SELECT name FROM student WHERE name = 'xx' or class = 'xxxx'; 
    -- or条件字段中gender字段没有索引，索引全部失效
    SELECT name FROM student WHERE name = 'xx' or gender = '男'; 
    ```

- 分布原则

    MySQL会对索引进行评估。如果MySQL认为不走索引更快，他就不会走索引。这个情况通常发生在范围查找中。

    假设有100名学生，id从1~100。

    ```
    -- 索引比遍历快，走索引
    SELECT name FROM student WHERE id > 80; 
    -- 索引比遍历慢，走遍历
    SELECT name FROM student WHERE id > 40; 
    ```



#### 指定索引

当一个字段有多个索引时，MySQL会评估索引，找出最高效的索引来使用。不过，我们仍然可以指定MySQL在查询时使用哪个索引。

- 使用USE INDEX指定使用哪个索引：

    ```
    SELECT 字段列表 FROM 表名 USE INDEX(索引名称) WHERE...;
    ```

- 使用IGNORE INDEX不使用哪个索引：

    ```
    SELECT 字段列表 FROM 表名 IGNORE INDEX(索引名称) WHERE...;
    ```

- 使用FORCE INDEX强制使用哪个索引：

    ```
    SELECT 字段列表 FROM 表名 FORCE INDEX(索引名称) WHERE...;
    ```




## 其他SQL的优化

在上一节中我们介绍了索引，索引是对DQL语句进行优化的。虽然在实际业务中DQL语句的使用确实最多，但使用其他语句的成分也不低。那么我们应该如何去优化其他语句呢？下文将进行介绍

### 插入数据优化

1. 使用insert插入数据时，一次性插入多条数据的性能要比分成单条数据逐条插入要好。因此建议插入多条。当然也不宜过多，一次性插入500-1000条是比较合适的。

2. 将插入语句包装成事务并手动提交，要比自动提交高效。

3. 按照主键顺序插入永远要比主键乱序插入的性能高。

4. 对于巨量数据的插入，insert插入性能较差。我们可以使用MySQL的load指令进行插入，load比insert要快速。但是load指令对数据格式有一定的要求。比如每一行数据按照","或"|"等字符对字段进行分隔，且数据与数据之间也有特殊符号进行分隔。

    使用方法如下：先准备好数据文件(假设为data.txt)和已经拥有对应字段的表，数据文件的样例为：

    > 张三,男,27,18812346987
    >
    > 李四,男,28,17245687931
    >
    > ...

```
#客户端连接服务端时，加上参数--local-infile
mysal --local-infile -u root -p
#设置全局参数local_infile为1，开启从本地加载文件导入数据的开关
set global local_infile =1;
#执行load指令将准备好的数据,加载到表结构中
load data local infile 'data.txt' into table '表名’ fields terminated by ',' lines terminated by '\n';
```

**<u>为什么主键顺序插入要比乱序插入高效？</u>**

在InnoDB引擎中，默认会为主键创建聚集索引，而聚集索引的叶节点会携带一整条的数据。

但是，InnoDB引擎中一个索引的节点就占一个页，一个页最大大小是16KB。而且B+树中叶节点还可以看作是一个链表。

当我们想插入数据时，如果页的剩余空间已经容不下新数据了，MySQL就会考虑页分裂，把一个页按照要插入的位置分为两半，前半部分呆在原来的页，且接收新数据插入，后半部分则另开辟一个页。分裂之后还要修改指针和索引结构。这个和B+树在插入的节点超过规定的度之后，向上分裂的现象是相似的。

当我们想删除数据时，如果一个页中的可用容量已经能够容纳指向的下一个页的内容了，那么这个页就会和下一个页合并，并修改指针和索引结构，以节省空间。

如果我们顺序插入，就和链表在尾部插入节点是一样的，非常快，只要考虑开辟新的页并让指针指向就好了。

如果我们乱序插入，就和我们在链表中间插入节点一样，比较慢，更糟的是，如果我们要插入的页装不下了，MySQL就要考虑页分裂，这个是比较慢的。

那么根据这个特性，我们可以**对主键做出以下优化**：

1. 主键的长度尽量降低。这个优化主要是针对二级索引的，因为二级索引的叶节点携带的是主键的数据。同时一个节点的最大空间就那么多，如果数据太大，在插入和删除时MySQL就会频繁地进行页分裂和页合并，降低性能。同时还可以节省磁盘空间。
2. 使用自增主键，这样可以保证顺序插入。
3. 尽量不要使用譬如身份证号、uuid这样的随机的、无序的字段来当主键。
4. 尽量不要修改主键。



### OEDER BY排序优化

MySQL有两种排序手段。

1. Using filesort：先全表扫描，得出结果集，再对结果集进行对应字段的排序。效率低。
2. Using index：根据索引，直接按照索引即可得出排序后的结果集。高效。

ORDER BY也可以使用索引。因为索引本身就是有序的。但是ORDER BY对索引有比较高的要求。因为它可以根据多个字段进行排序，也可以设置降序或升序。ORDER BY中的字段顺序关系到使用索引的情况，它会依次地使用字段的顺序去使用相关索引。如果使用了联合索引，那么排序字段也要根据联合索引的顺序来才能完全使用联合索引。否则索引将半失效。

比如有索引`idx_From_A_B`，那么`ORDER BY A,B`可以完整地使用索引，而`ORDER BY B,A`则会导致字段B走索引，而字段A走全表扫描排序。

索引默认是按照升序插入的，如果我们倒序排序，对于普通索引会使用倒查，对于联合索引可能会导致联合索引部分失效。

比如有索引`idx_From_A_B`，那么`ORDER BY A,B`可以完整地使用索引，而`ORDER BY A,B desc`则会导致字段A走索引，而字段B走全表扫描排序。

在之前介绍创建索引的时候，我们提过自定义顺序创建索引。这时候就可以派上用场了。假设有索引`idx_From_A_B_ad`（后面的ad表示第一个字段是asc，第二个字段是desc），那么`ORDER BY A,B desc`也可以完整地使用索引。

我们在频繁使用ORDER BY的场景中，尽量不要让MySQL使用Using filesort全表扫描排序。
