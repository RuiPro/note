## Git

Git是最出色的开源版本控制工具。

Git与其他版本控制工具相比，最大特性是Git是分布式管理，而其他版本控制工具是集中管理。

集中管理的方式虽然安全性和统一性高，但它的弊端也很多，你需要和服务器建立稳定的连接，而且如果服务器发生回滚或更改，那么所有人都要进行同步更新；如果你本地切换了分支，你需要服务器也跟着你切换分支才有效。

分布式管理意味着一个仓库可以有很多很多的副本。你可以在你的副本上进行任何操作，别人也可以在别人的副本上进行任何操作。当大家都操作完毕后，可以统一将副本的更改提交到一个服务器上。不过，服务器也只是负责记录而已，修改服务器并不强制要求本地的副本也进行更新。

Git的中文文档：https://git-scm.com/book/zh/v2



## Git仓库组成

一个Git仓库由工作区、版本库和版本库下的暂存区组成。

你可以在你的项目目录下使用`git init`命令来初始化一个Git仓库。该命令会在项目目录下创建一个不可见的`.git`文件夹。

- 工作区：就是你的项目目录
- 暂存区：暂存区就是`.git/index`文件，也叫索引，负责记录你对工作区的更改。暂存区维护了一棵当前分支的对象树，对象树的结点是Git对象。你可以使用`git add file`将工作区的文件生成Git对象并挂到对象树上。
- 版本库：版本库就是整个`.git`文件夹。负责记录某个时间点的目录树，就是把当前保存在暂存区的对象树保存一个快照到版本库里面，版本库也是以Git对象的形式进行保存的。你可以使用`git commit`将暂存区的对象树和目录结构生成Git对象并保存到版本库里。



## Git对象

你注意到涉及Git的操作都有Git对象。Git对象是Git进行版本控制的核心。

Git对象分成四类：

- Blob对象：就是文件对象，内部保存了文件的内容和其他信息。你工作区的每个文件在挂到暂存区的对象树上后就是这样的形式存在。
- Tree对象：目录结构对象。内部保存着你的某个目录下的文件信息，包括该目录下的目录对应的Tree对象和文件对应的Blob对象
- Commit对象：提交对象包含了一次提交信息。包含以下数据：作者、提交者、提交日期和提交信息，以及该次提交时暂存区项目根目录的Tree对象。如果不是第一次提交，还会有parent信息指向上一次的提交的Commit对象。通常parent只有一个，但如果发生了分支合并，可能会有多个。
- Tag对象：Tag对象用于给特定的commit打标签，通常用于发布新版本时。

Git对象都被放在`.git\objects`文件夹下。

Git会根据文件的内容来生成Git对象的名称。生成的原理是哈希，哈希可以得到某个内容的40位哈希值，这个哈希值只能通过计算这个内容得到，且保证相同内容计算得到的哈希值也一定相同。因此，相同的文件信息计算出来的哈希值也相同，那么根据哈希值得到的Git对象也相同；只要文件发生了更改，就一定会生成不同的Git对象，Git就是这样进行使用Git对象进行版本控制的。

Git会使用哈希值生成的文件名称进行分类：哈希值的前2个字符作为文件夹，后38个字符作为文件名。这样在某文件夹下的某Git对象的哈希值就是文件夹名称和文件名称的拼接。



## Git引用

Git引用是一个文件，该文件可以帮你保存Git对象的哈希值，进而帮你找到某个提交节点。如果没有Git引用，你只能通过提交的Commit对象的哈希值来定位提交节点。你可以在 `.git/refs` 目录下找到这类含有哈希值的文件。

Git引用指向提交的节点，如果仓库没有任何提交，也就自然地不会有Git引用文件。

在默认情况下，Git会在你第一次提交的时候创建一个master分支，master就是一个Git引用，它指向你的第一次提交。

你可以使用这个命令手动创建一个引用：

```
git update-ref refs/heads/ref_name 40位哈希值
```

此时，你会创建一个名字为ref_name的Git引用，引用哈希值为你提供的哈希值的那次提交。

Git引用是分支管理的核心，每个分支都会有一个分支引用，或者说每个引用都会成为一个分支。所以上面那个命令实际上会创建一个分支`ref_name`。



### HEAD引用

HEAD是一个保存你当前正在工作的提交节点的引用，它告诉Git你当前正在哪个分支的哪个提交上工作。

> 有些地方也会称HEAD为指针，其实都是一样的

HEAD引用对应的文件是`.git/HEAD`，HEAD引用只有一个。通常情况下，HEAD会引用其他引用，比如你在master分支下工作，那么HEAD就会引用master：`ref: refs/heads/master`。一般情况下，HEAD会随着分支的提交自动更新引用(其实HEAD的文件内容没有动，动的只是HEAD指向的引用)，也就是分支提交时，分支引用和HEAD引用会一起同步前进。

你可以手动地指定HEAD分支引用的对象，此时你的HEAD就不再引用其他引用了，而是保存某个Git对象(通常是Commit对象)的哈希值。此时你的HEAD引用就被分离了，Git会提示你进入了HEAD分离状态：`You are in 'detached HEAD' state.`，此时你的提交只会让HEAD发生更新，而不会记录到任何分支下，除非你回到分支引用或手动将分支引用修改为你的提交。

总结规律：

1. 如果HEAD指向其他引用，那么对HEAD的修改就是在修改HEAD指向的引用，HEAD本身不会被修改
2. 如果HEAD未指向其他引用也就是HEAD分离状态，对HEAD的修改才是真的修改HEAD

因为是提交链，所以可以通过HEAD往前找到历史提交版本：

- `HEAD` 表示当前版本
- `HEAD^` 上一个版本
- `HEAD^^` 上上一个版本
- `HEAD^^^` 上上上一个版本
- 以此类推...

也可以使用`~数字`表示

- `HEAD~0` 表示当前版本
- `HEAD~1` 上一个版本
- `HEAD^2` 上上一个版本
- `HEAD^3` 上上上一个版本
- 以此类推...



## 分支

分支是Git的特色功能。其他版本控制工具都是将源代码复制一份到其他地方来创建分支，而Git则使用了更为高效的方式：使用提交的引用。并且，合并分支也是Git强强项。得益于分支功能，软件开发可以更好的对源代码进行控制了，比如稳定版、快照版、测试版、决议版可以使用不同的分支，而当测试版通过维护变得稳定时，就可以合并到稳定版，这样做是很方便的。

分支是Git帮你多定义一个Git引用指向新的分支，这样你可以很方便地在分支间进行转换，你已经在Git引用小节中尝试过通过添加引用的方式来在特定的提交节点创建分支了，这种方法是在走过的路上开辟新道路。不过，需要手动指定节点来创建分支的情况下比较少见，更多情况下我们需要在当前最新的提交节点下创建分支，也就是开多岔路。



### 查看分支

你可以使用这个命令查看当前所有分支，带`*`号且标绿的是当前分支。

```
git branch
```



### 创建分支

你可以使用这个命令来创建一个名为`branchname`的分支，这个分支会在你的HEAD引用处创建。

```
git branch branchname
```

此时，在 `.git/refs` 目录下会多出一个Git引用文件来保存你的分支引用。



### 转到分支

你可以在多个分支之间自由切换，而不需要使用哈希值。切换分支会让你的HEAD引用转到目标分支引用。**不过请注意，切换分支会将你的工作区和暂存区也一并重置到目标分支的状态，使其看起来像回到了你在那个分支上最后一次提交的样子。**这是危险操作，请在切换分支前提交你的更改，否则你在工作区未提交的作业量将不复存在。

```
git checkout branchname
```

利用这个特性，我们在进行开发时，如果想使用“梁非凡桌面清理大法”，你可以在未提交时使用这个命令，将你的工作区和暂存区回到上一次提交时的状态

```
git checkout HEAD
```

你可以通过携带`-b`参数来创建并切换到一个分支。

```
git branch -b branchname
```



### 删除分支

删除分支只会删除指向该分支的Git引用，而实际不会删除该分支下的提交。在在清理对象文件前，你仍然可以通过哈希值访问已经删除的分支的提交节点。

```
git branch -d branchname2remove
```



### 分支合并

当存在多个分支时，你可以对多个分支进行两两合并。合并可以让一个分支使用另一个分支的内容对自己进行补充。

下面这个命令可以让目标分支的某个提交节点的内容补进当前HEAD引用指向的提交节点，并自动提交一次。

```
git merge target
```

当然，有时候合并并不是那么顺利，当目标节点和当前节点都对某一块内容进行了独特的修改时，Git无法简单地进行补充，就会发生合并冲突。

Git 做了合并，但是没有自动地创建一个新的合并提交。 Git 会暂停下来，等待你去解决合并产生的冲突。 你可以在合并冲突后的任意时刻使用 `git status` 命令来查看那些因包含合并冲突而处于未合并（unmerged）状态的文件，然后修改它们直到它们不再冲突。在处理完冲突之后，你可以使用`git add file`来完善对象树中发生冲突的文件。

合并完成之后，当前分支已经进行使用另一个分支的内容进行了补充，Git不会删除另一个分支，你可以自行决定另一个分支的去留。比如另一个分支是bug修复，那么将bug修复补充进主分支后应该删除；而如果另一个分支是开发版，那么合并后开发版可以继续添加主分支没有的内容。



### 分支管理

可以使用`git branch`的参数`--merged`与`--no-merged`来列出哪些分支没有被合并或已经被合并，也就是找出哪些分支有比当前分支多的内容。



### 变基

变基是Git的另一种合并代码的方式。

变基的原理是：把本分支所做的修改和目标分支对比，然后带着自己的特产去目标分支家里，两个人一起住同一个分支。

与合并不同，合并是一个分支看到其他分支有特产，就去把其他分支的特产拷贝一份过来，但合并之后两个分支还是各住各的。

我建议是不要使用变基，尤其是一个仓库的维护者不止一个人的情况下，毕竟人多起来之后，大家一起住在一起，谁写的代码都分不清了。



## Git工作流程

### 创建仓库

这条命令将(初始化)创建一个空仓库。如果仓库已经存在，则不会创建。

```
git init
```

1. 在项目目录下创建一个不可见的`.git`文件夹充当版本库
2. 在`.git`文件夹里面创建索引暂存区和配置文件，此时暂存区是空的



### 往暂存区添加文件

这条命令将工作区中的文件放到暂存区里。

```
git add file
git add .				# 表示把当前目录下所有文件都添加到暂存区
```

1. 遍历工作区目录下的每个文件，如果文件未进行更改就跳过，如果更改或添加了文件，则将文件重新生成为Blob对象，放到`.git\objects`文件夹里。
2. 如果目录和目录下的文件发生了更改，那么更新暂存区的目录结构，也就是更新对象树的根Tree对象，但此操作的Tree对象不会放到`.git\objects`文件夹里。
3. 更新暂存区的对象树，从对象树上移除删除的文件的Blob对象，添加新建的文件的Blob对象，修改已经编辑的文件的Blob对象，使对象树上挂的Blob对象始终为最新



### 将暂存区的更改进行提交

这条命令将提交你的暂存区提交到当前分支。

```
git commit -m "必须填写提交信息"
```

1. 生成暂存区的对象树的Tree对象并放到`.git\objects`文件夹里
2. 使用作者、提交者、提交日期、提交信息和暂存区的对象树根Tree对象生成一个Commit对象，并放到`.git\objects`文件夹里
3. 将HEAD指向分支新提交的节点。如果是第一次提交，会创建一个master分支，然后HEAD会指向该master分支。

如果你不知道当前分支是哪个分支、哪些文件会被提交，你可以输入下面这条命令查看

```
git status
```



### 回退版本

也许你玩`git add`添加了很多乱七八糟的东西而且删除起来非常耗时，或者`git commit`粗心漏掉了某个文件，但你已经执行了操作，此时你迫切需要回滚。

这条命令可以让你的暂存区回滚到某个提交节点。回推到某个提交节点之后，如果该节点之后还有提交，那么在该节点之后的提交会被封存。不过，你仍然可以在清理对象文件前通过哈希值回到前面的节点。

此命令可以使用提交的哈希值或Git引用来回退到特定的版本。你可以通过 `git log` 命令找到你想要回退到的提交的哈希值。不过，回滚到目标节点之后，再使用 `git log` 命令不会列出目标节点之后的提交。

> 回退版本可以让你在不同的时间线穿梭。假设现在有一串提交记录：a-b-c-d-e-f-g，现在HEAD指向g。你回滚了5个版本，现在你回到了版本b。之后你的提交都会跟在b的后面，比如你又提交了x，那么提交链会变成a-b-x。提交记录c-d-e-f-g会在清理对象文件前一直存在。如果你某一天又回到版本g了，那么你在b后面提交的版本x以及之后的更多版本都会被封存。这样看起来你就像在两个时间线穿梭，不过，尽量避免这种情况，如果你真的想实现时间线穿梭，请使用分支功能。

```
git reset [--mixed](默认)或[--soft]或[--hard] Git对象的哈希值或Git引用
```



三个参数：

- `--mixed`：用于将HEAD引用的分支引用回退到已经提交的某个节点，并将你的暂存区回退到该分支节点状态。不会改动你的工作区，也不会同步回滚`.git\objects`文件夹里的Git对象
- `--soft`：用于将HEAD引用的分支引用回退到已经提交的某个节点，和`--mixed`参数不同，这个参数不会改动你的暂存区，不会改动你的工作区，也不会同步回滚`.git\objects`文件夹里的Git对象
- `--hard`：用于将HEAD引用的分支引用回退到已经提交的某个节点，并且，回退暂存区和工作区到该分支节点状态。这是危险操作！你的工作区会被替换到曾经的提交的某个节点，这可能会让你的文件丢失。

`git reset --hard`和`git checkout`都能将工作区、暂存区、HEAD引用回到某个提交节点。但是，它们也是存在区别的：`git checkout`只是将HEAD指向目标提交节点，而`git reset --hard`如果HEAD指向的是一个Git引用，那么会通过修改Git引用来指向目标提交节点，而自己不变；如果HEAD指向的是一个哈希，也就是你处于HEAD分离状态，则`git reset --hard`和`git checkout`是一样的。



## 远程仓库

Git远程仓库可以为你托管仓库。远程仓库是多人协作的必备条件。由于Git使用的是分布式管理，远程仓库也只是项目的一个镜像，只不过大家都约定把自己的工作量放到仓库上，确保远程仓库的代码是最新的。 

远程仓库对本地仓库来说就是一个分支，而且这个分支不能手动更改，只能通过连接服务器进行同步的方式来让这个分支得到更新。远程仓库的分支以 `remote/branch` 的形式命名，`remote`是本地标示的主机名称，如果不提供，默认就是`origin`。`branch`就是远程仓库的某个分支。比如`origin/matser`指的就是远程仓库的`master`分支，这个分支和本地的`master`分支是不一样的。

> 远程仓库名字 “origin” 与分支名字 “master” 一样，在 Git 中并没有任何特别的含义一样。 同时 “master” 是当你运行 `git init` 时默认的起始分支名字，原因仅仅是它的广泛使用， “origin” 是当你运行 `git clone` 时默认的远程仓库名字。 如果你运行 `git clone -o booyah`，那么你默认的远程分支名字将会是 `booyah/master`。

### 克隆远程仓库

从0开始从远程仓库复制一份仓库到本地的方式叫克隆。你可以使用这个指令克隆一份仓库

```
git clone 远程仓库地址
```

克隆完成后，本地仓库和远程仓库的内容就是一模一样的。

克隆后，Git会自动将该远程仓库添加到本地仓库，添加的远程仓库会默认命名为`origin`。



### 查看本地仓库配置的远程仓库

你可以使用下面的命令来查看你的本地仓库配置了哪些远程仓库

```
git remote
```

还可以加上`-v`参数来列举远程仓库的地址

```
git remote -v
```

还可以使用这个命令来查看远程仓库的详情

```
git remote show 远程仓库名
```



### 添加远程仓库

你可以为你的已有的本地仓库添加远程仓库，这样你可以将本地仓库的内容推送到远程，也可以获取远程仓库的内容

```
git remote add 远程仓库名 远程仓库地址
```

如果你想对仓库名进行重命名，使用

```
git remote rename 旧远程仓库名 新远程仓库名
```



### 移除远程仓库

你可以移除某个远程仓库与本地仓库的关联

```
git remote remove 远程仓库名
```



### 从远程仓库中抓取和拉取

远程仓库也在实时更新。当多人一起维护一个远程仓库时，在你完成作业的期间，其他人可能对远程仓库进行了更新。

假设远程仓库有一条分支：a-b-c-d，其中master引用d

你在版本d对仓库进行了克隆，你的本地仓库也存在一条分支：a-b-c-d，其中本地master指向d，origin/master也指向d

一段时间后，远程仓库由其他人维护到了版本h：a-b-c-d-e-f-g-h，而你为本地仓库添加了两个版本x和y：a-b-c-d-x-y，其中本地master指向y，但origin/master仍然指向d

此时你可以通过这条命令来抓取本地没有的远程仓库内容：

```
git fetch 远程仓库名 远程分支名称
```

远程分支名称是可选的，如果不提供，那么Git会抓取与当前分支名称一样的分支。如果远程仓库没有本地仓库当前的分支名称或你提供的分支名称，Git会提示你不在任何一个分支上，并列出远程仓库的所有分支。

你使用`git fetch origin master`称抓取成功后，你的本地就存在两个分支了：a-b-c-d【-x-y】|【-e-f-g-h】，其中本地master指向y，但origin/master指向h

你可以通过合并的方式来使你的本地master得到更新。

这种方式每次都要抓取然后切换到远程分支、合并，Git为我们提供了一键抓取与合并，称为拉取：

```
git pull 远程仓库名 远程分支名称
```

和`git fetch`一样，远程分支名称是可选的，如果不提供，那么Git会抓取与当前分支名称一样的分支。如果远程仓库没有本地仓库当前的分支名称或你提供的分支名称，Git会提示你不在任何一个分支上，并列出远程仓库的所有分支。

`git pull`会执行`git fetch`，然后自动合并到本地仓库的分支的HEAD引用。这意味着`git pull`也是以HEAD引用为主的，最好在`git pull`时避免处于HEAD分离状态。



### 推送到远程

你可以使用这条命令将你的本地仓库推送到远程

```
git push 本地分支名称 远程服务器
```

只有当你有所克隆服务器的写入权限，并且之前没有人推送过时，这条命令才能生效。并且，你必须先抓取他们的工作并将其合并进你的工作后才能推送，这样才能确保远程仓库的分支是最新的
