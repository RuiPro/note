# Git

Git是最出色的开源版本控制工具。

Git与其他版本控制工具相比，最大特性是Git是分布式管理，而其他版本控制工具是集中管理。

集中管理的方式虽然安全性和统一性高，但它的弊端也很多，你需要和服务器建立稳定的连接，而且如果服务器发生回滚或更改，那么所有人都要进行同步更新；如果你本地切换了分支，你需要服务器也跟着你切换分支才有效。

分布式管理意味着一个仓库可以有很多很多的副本。你可以在你的副本上进行任何操作，别人也可以在别人的副本上进行任何操作。当大家都操作完毕后，可以统一将副本的更改提交到一个服务器上。不过，服务器也只是负责记录而已，修改服务器并不强制要求本地的副本也进行更新。



# Git本地工作原理

## Git仓库组成

一个Git仓库由工作区、版本库和版本库下的暂存区组成。

你可以在你的项目目录下使用`git init`命令来初始化一个Git仓库。该命令会在项目目录下创建一个不可见的`.git`文件夹。

- 工作区：就是你的项目目录
- 暂存区：暂存区就是`.git/index`文件，也叫索引，负责记录你对工作区的更改。暂存区维护了一棵当前分支的对象树，对象树的结点是Git对象。你可以使用`git add file`将工作区的文件生成Git对象并挂到对象树上。
- 版本库：版本库就是整个`.git`文件夹。负责记录某个时间点的目录树，就是把当前保存在暂存区的对象树保存一个快照到版本库里面，版本库也是以Git对象的形式进行保存的。你可以使用`git commit`将暂存区的对象树和目录结构生成Git对象并保存到版本库里。



## Git对象

你注意到涉及Git的操作都有Git对象。Git对象是Git进行版本控制的核心。

Git根据文件信息来生成Git对象。生成Git对象的原理是哈希，哈希可以得到某个内容的40位哈希值，这个哈希值只能通过计算这个内容得到，且保证相同内容计算得到的哈希值也一定相同。因此，相同的文件信息计算出来的哈希值也相同，那么根据哈希值得到的Git对象也相同；只要文件发生了更改，就一定会生成不同的Git对象，Git就是这样进行使用Git对象进行版本控制的。

Git对象分成四类：

- Blob对象：就是文件对象。你工作区的每个文件在挂到暂存区的对象树上后就是这样的形式存在。
- Tree对象：目录结构对象。保存着你的某个目录下的文件信息，包括该目录下的目录对应的Tree对象和文件对应的Blob对象
- Commit对象：提交对象包含了一次提交信息。包含以下数据：作者、提交者、提交日期和提交信息，以及项目根目录的Tree对象
- Tag对象：Tag对象用于给特定的commit打标签，通常用于发布新版本时。

Git对象都被放在`.git\objects`文件夹下，且使用哈希值进行分类：哈希值的前2个字符作为文件夹，后38个字符作为文件名。这样在某文件夹下的某Git对象的哈希值就是文件夹名称和文件名称的拼接。



## HEAD指针

HEAD是一个指向你当前正在工作的最新提交的节点的指针，它告诉Git你当前正在哪个分支的哪个提交上工作。

HEAD 说明：

- `HEAD` 表示当前版本
- `HEAD^` 上一个版本
- `HEAD^^` 上上一个版本
- `HEAD^^^` 上上上一个版本
- 以此类推...

也可以使用`~数字`表示

- `HEAD~0` 表示当前版本
- `HEAD~1` 上一个版本
- `HEAD^2` 上上一个版本
- `HEAD^3` 上上上一个版本
- 以此类推...



## Git单分支工作流程

### 创建仓库

这条命令将(初始化)创建一个空仓库。如果仓库已经存在，则不会创建。

```
git init
```

1. 在项目目录下创建一个不可见的`.git`文件夹充当版本库
2. 在`.git`文件夹里面创建索引暂存区和配置文件，此时暂存区是空的
3. 创建一个默认分支master
4. 将HEAD指向master



### 往暂存区添加文件

这条命令将工作区中的文件放到暂存区里。

```
git add file
git add .				# 表示把当前目录下所有文件都添加到暂存区
```

1. 遍历工作区目录下的每个文件，如果文件未进行更改就跳过，如果更改或添加了文件，则将文件重新生成为Blob对象，放到`.git\objects`文件夹里。
2. 如果目录和目录下的文件发生了更改，那么更新暂存区的目录结构，也就是更新对象树的根Tree对象，但此操作的Tree对象不会放到`.git\objects`文件夹里。
3. 更新暂存区的对象树，从对象树上移除删除的文件的Blob对象，添加新建的文件的Blob对象，修改已经编辑的文件的Blob对象，使对象树上挂的Blob对象始终为最新



### 将暂存区的更改进行提交

这条命令将提交你的暂存区提交到当前分支。

```
git commit -m "必须填写提交信息"
```

1. 生成暂存区的对象树的Tree对象并放到`.git\objects`文件夹里
2. 使用作者、提交者、提交日期、提交信息和暂存区的对象树根Tree对象生成一个Commit对象，并放到`.git\objects`文件夹里
3. 将HEAD指向分支新提交的节点

如果你不知道当前分支是哪个分支、哪些文件会被提交，你可以输入下面这条命令查看

```
git status
```



### 重置工作区



### 回退版本

也许你玩`git add`添加了很多乱七八糟的东西而且删除起来非常耗时，或者`git commit`粗心漏掉了某个文件，但你已经执行了操作，此时你迫切需要回滚。

这条命令可以让你的暂存区回滚到某个分支的节点。回滚到某个节点之后，如果该节点之后还有提交，那么在该节点之后的提交会被封存。不过，你仍然可以在清理对象文件前通过哈希值回到前面的节点。

> 回退版本可以让你在不同的时间线穿梭。假设现在有一串提交记录：a-b-c-d-e-f-g，现在HEAD指向g。你回滚了5个版本，现在你回到了版本b。之后你的提交都会跟在b的后面，比如你又提交了x，那么提交链会变成a-b-x。提交记录c-d-e-f-g会在清理对象文件前一直存在。如果你某一天又回到版本g了，那么你在b后面提交的版本x以及之后的更多版本都会被封存。这样看起来你就像在两个时间线穿梭，不过，尽量避免这种情况，如果你真的想实现时间线穿梭，请使用分支功能。

```
git reset [--mixed](默认)或[--soft]或[--hard] [HEAD]或哈希值
```

此命令可以使用提交的哈希值来回退到特定的版本。你可以通过 `git log` 命令找到你想要回退到的提交的哈希值。

三个参数：

- `--mixed`：用于将HEAD指向已经提交的某个节点，并将你的暂存区回退到HEAD指向的分支节点状态。不会改动你的工作区，也不会同步回滚`.git\objects`文件夹里的Git对象
- `--soft`：用于将HEAD指向已经提交的某个节点，和`--mixed`参数不同，这个参数不会改动你的暂存区，不会改动你的工作区，也不会同步回滚`.git\objects`文件夹里的Git对象
- `--hard`：用于将HEAD指向已经提交的某个节点，并且，回退暂存区和工作区。这是危险操作！你的工作区会被替换到曾经的提交的某个节点，这可能会让你的文件丢失。



## 分支

分支是Git的特色功能。其他版本控制工具都是将源代码复制一份到其他地方来创建分支，而Git则使用了更为高效的方式：使用提交的引用。并且，合并分支也是Git强强项。得益于分支功能，软件开发可以更好的对源代码进行控制了，比如稳定版、快照版、测试版、决议版可以使用不同的分支，而当测试版通过维护变得稳定时，就可以合并到稳定版，这样做是很方便的。

分支的功能得益于提交。在介绍回滚命令`git reset`时，你可能已经体会到了。分支就像`git reset`回滚了并在历史节点进行了提交一样，不过回滚之后旧的提交只能通过哈希转回来，而分支则是Git帮你多定义一个HEAD记录，这样你可以很方便地在分支间进行转换。



