## 编译器的构成

我们以Linux下的C编译器GCC为例，了解一下编译器的功能和构成。

编译器由四个部件组成：预处理器、编译器、汇编器和链接器
$$
C语言源码 \quad main.c \quad int\ main()\{...\} 
\\ 预处理器↓gcc\ -E  \ \ \ \ 
\\ C语言源码 \quad main.c \quad int\ main()\{...\} 
\\ 编译器↓gcc\ -S \ 
\\ 汇编文件 \quad main.s \quad pushq\ \%rbx  \ \ \ 
\\ 汇编器↓gcc\ -c
\\ 二进制文件 \quad main.o \quad 53\ 48\ 00\ d3\ ...  \ 
\\ 链接器↓gcc \ \ \ \ \ \ \ \ \ 
\\ 二进制文件 \quad main \quad 53\ 48\ 89\ d3\ ...  \ \ \ \ \
$$

- 预处理器：宏操作(比如#include是把头文件中的所有内容拷贝一份，#define替换)、去注释

- 编译器：把预处理过后的源码编译成汇编代码，此过程会检查语法(比如括号匹配)，生成符号表用于管理变量

  符号表是编译器管理标识符的重要工具。符号表中保存了标识符的类型、地址和作用域。其数据结构是表+树，每个作用域都是一个表，如果这个作用域还有子作用域，那么此作用域的符号表还会保存一个指针指向子作用域的符号表，而且这个指针是双向的。

  符号表中保存的符号类型可以分为三种：已经定义的全局符号、未定义的全局符号和本地符号。

  - 已经定义的全局符号：在本对象文件中定义，并且能在其他文件使用
  - 未定义的全局符号：在本对象文件中没有定义就使用的符号
  - 本地符号：只能在本对象文件中使用的符号，比如函数内部局部变量、static修饰的变量

  你可以使用`nm`命令来查看一个对象文件的符号表

  - **U**：未定义的符号Undefined symbols，在本对象文件中使用但未定义
  - **D**：已定义的数据符号Defined data symbols，在本对象文件定义的变量
  - **T**：已定义的代码符号Defined code symbols，在本对象文件定义的函数
  - **d**：已定义的局部数据符号，在本对象文件定义的局部变量
  - **t**：已定义的局部代码符号，在本对象文件定义的局部函数

- 汇编器：把汇编代码汇编成可成重定位二进制文件，可重定位是指此时的二进制文件在内存中的地址是不确定的，代码中所有位置都是相对地址，相对地址必须确定程序起始位置才能清楚自己在内存中的位置，同时导出重定位表

  重定位表保存了需要重定向的对象和函数地址，你可以使用命令`objdump`来查看一个对象文件的重定位表

- 链接器：链接器确定程序起始地址，链接器检查重定位表和符号表，如果重定位表中每个符号都能在符号表中找到并且确定地址，就可以把多个可成重定位二进制文件链接在一起形成一个可执行的二进制文件，如果发生了某个符号缺失或找不到地址，链接器会报未定义标识符的错误



### 楔子

C++中有inline、extern和static三个关键字，可以在你对变量或者函数进行定义时放到前面。

> 什么你说还有const和volatile？
>
> const代表常量限定符，告诉编译器这是一个常量，可以进行常量优化；volatile代表易变符，告诉编译器这个值是易变的，编译器因此不对它进行严格的优化，使其在读取时能够保证读到的值和内存中的一致。
>
> cv限定和inline、extern、static这三个关键字无关，你完全可以搭配使用，甚至const和volatile都能一起使用。



### 唯一定义原则

唯一定义原则就是在编译后每个符号只允许有一个定义。

因此，在整个工程文件(无论是可执行还是库)中，变量或函数可以有多个声明，但定义只能有一个。



### 作用域与命名空间

#### 作用域

作用域是一个范围，这个范围规定了：

1. 函数或对象在代码中的可见性和生命周期
2. 函数或对象的定义在链接时的唯一符号(唯一定义原则)

在C++中有许多作用域：

1. 全局作用域，这个作用域默认存在，类、命名空间和函数外的函数或对象都属于全局作用域。全局作用域的函数或对象可以在任何地方访问。全局变量在程序开始时被创建，在程序结束时被销毁
2. 函数作用域，这个作用域指的是函数体，函数作用域内只能定义对象，不能定义函数，且定义的对象只有此函数接下来的部分可以访问。
3. 类作用域，在类名内定义的函数或对象都属于类作用域，只能通过类或者类的实例化对象进行访问
4. 块作用域，在代码块内定义的作用域，比如for、if等的控制流主体，和函数作用域类似，作用域内只能定义对象，且定义的对象只有此作用域接下来的部分可以访问

#### 命名空间

命名空间可以用于区分同一作用域下的相同成员。你可以把命名空间视为作用域下的子作用域，命名空间的限制与外部作用域一致。



### 声明和定义

声明是指你告诉编译器有这个东西，但你暂时不给他实现。

定义是你给了编译器一个真正可以用的东西。定义需要讲究命名空间和作用域，在同一作用域或命名空间下，只能存在一个定义。

对于函数，你可以不写函数体和形参名，这样就是一个函数声明，只要你写了函数体，即使函数体里面什么都不写，都算一个定义。

对于对象，对象就比较难受了，因为你可以在定义时不初始化，比如`int i;`和`int i = 100;`这两个都是定义。



### static

static关键字在C中只有2层含义：

1. 使变量转为在该命名空间下静态存储，而且这个静态存储是每个链接对象.o独有的，且只有此编译单元关联的源代码可以使用。不管你在哪个作用域，只要在一个编译单元内声明为static，就会被静态存储。

   **在导出符号表时，static会将符号转成本地符号**

   此时，定义的符号会在程序开始运行时初始化。

   main.cpp

   ```
   #include <iostream>
   #include "foo.h"
   using namespace std;
   
   static int i = 666;				// 此处定义了i
   
   int main(){
       cout << i << endl;
       func();
       return 0;
   }
   ```

   foo.h

   ```
   #ifndef FOO_H
   #define FOO_H
   
   void func();
   
   #endif //FOO_H
   ```

   foo.cpp

   ```
   #include "foo.h"
   #include <iostream>
   using namespace std;
   
   static int i = 100;					// 此处又定义了i
   
   void func(){
       cout << i << endl;
   }
   ```

   这三个文件最终会被编译成两个对象：main.o和foo.o，再进行链接成可执行文件。main.cpp里定义的i只能在main.cpp里使用，foo.cpp里定义的i只能在foo.cpp里使用。

   

2. 如果在块作用域声明中定义static对象，此对象也只会被定义一次，超出一次的定义会被忽略。

   此时，定义的符号会在第一次访问时初始化。

   ```
   #include <iostream>
   using namespace std;
   
   int main(){
       for(int i = 1; i < 10; ++i){
           static int num = 666;
           cout << num << endl;
           ++num;
       }
       return 0;
   }
   ```

   在for语句中循环10次定义num，但只有第一次定义有效，后面的定义都是在使用已经定义的num。

在CPP里，static还有声明不绑定到特定实例的类成员的作用，涉及面向对象，这里不展开讨论。



### extern

extern关键字表明这是一个声明。

当函数没有添加函数体时，默认是extern的。

你可以将extern关键字加到定义中，这样extern关键字会失效，然后编译器会给你一个警告。

还记得变量的定义和声明吗？`int i;`和`int i = 100;`这两个都是定义，但现在，你可以使用`extern int i;`对变量进行声明了。



### inline

inline关键字表明接下来的定义不必遵循唯一定义原则(只是写的时候不遵循，最终的二进制文件必须遵循)。

inline关键字声明的对象在编译阶段不会冲突，而是共享同一个(唯一定义原则)

当存在多个inline关键字的定义时，编译器会随机选一个作为真正的定义(实际上是UB，但效果就是随机选)。

有什么用？

main.cpp

```
#include <iostream>
#include "foo.h"
using namespace std;

int main(){
    cout << i << endl;
    func();
    return 0;
}
```

foo.h

```
#ifndef FOO_H
#define FOO_H

inline int i = 100;					// 此处定义了i
void func();

#endif //FOO_H
```

foo.cpp

```
#include "foo.h"
#include <iostream>
using namespace std;

void func(){
    cout << i << endl;
}
```

这三个文件最终会被编译成两个对象：main.o和foo.o，再进行链接成可执行文件。但是main.o和foo.o都有一个i，这违反了唯一定义原则，但这是合法的，编译器把i共享。实际上你可以把它当作一个可以跨文件的static来用。



