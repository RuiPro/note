## 值

值，value，是内存中数据的一种抽象。计算机只能将0和1保存在电路中，但0和1不是给人看的，所以就有了值的概念：计算机如何向你解释0和1。一个值有两个基础属性：值大小和值类型。值大小就是数据的大小，比如0xFFFFFFFF，而值类型则说明了是哪种数据，比如int，char等等。一个值只要有这两个属性就可以用了。

> C++是强类型语言，你必须在使用一个值的时候定义它的类型。相对的，弱类型语言比如PHP、JavaScript，他们在使用值时不需要提供类型，但其实人家还是有类型的，只不过是语言解释器默默地在帮你判断类型。

此外，值还有很多其他的属性，比如按照是否可读写分为常量和变量，比如根据类型的定义方式分为基础类型和复合类型...以及，按值类别区分的左值和右值。



## 左值和右值

左值和右值最初是用来区分值是否能被取地址的值。能得到地址的是左值，不能则为右值。C++11之前标准委员会并没有明确定义左值和右值，所以左值和右值是大家一起约定俗成的说法：因为左值可以得到地址，所以左值通常被放在赋值运算符`=`的左边，右值只能读取值大小，所以被放在`=`的右边，这就是为什么他们叫左值和右值。

在C++11以后，出现了移动语义，移动语义可以转移资源所有权，这种行为好比“偷窃”或”接管“。移动语义来了之后就有意思了，曾经的左值可以不再需要有自己的值大小，它可以去“偷窃”或”接管“一个右值的值大小，而被“偷窃”或”接管“的右值，在被掏空之后，对它取值大小已经没有意义了，这种值你说他是右值吧，它又不能再使用，你说他不是右值吧，那他也不是左值呀。

因此，C++11跟随着移动语义一起来的是对值类别新的定义，这是由C++标准委员会制定的。C++11将值分为泛左值、纯右值和将亡值，并且将拥有三个值类别属性的对象由单纯的变量提升成为了表达式。



### 表达式

> C++ Primer第120页：
>
> 表达式由一个或多个运算对象组成，对表达式求值将得到一个结果。字面量和变量是最简单的表达式，其结果就是字面量和变量的值。把一个运算符和一个或多个运算对象组合起来可以生成较复杂的表达式。

表达式有两个关键的元素：变量或字面量、运算符。运算符是可选的，但变量或字面量是必须存在的。

运算符有一元运算符和多元运算符，比如取地址符`&`、递增运算符`++`是一元运算符，而加法`+`是二元运算符，`a?b:c`则是三元运算符。此外，还有一些特殊的运算符，比如函数调用运算符`()`、`sizeof()`运算符。

不过需要注意的是，赋值运算符可以和声明写在一起，此时就不叫赋值表达式了，而是一个带初始化的声明语句。



### 泛左值

泛左值是指可以取地址的表达式。它包括所有需要程序员起名字的变量和可以取地址的表达式。可以取地址意味着我们可以使用泛左值随时定位到一个值大小。泛左值具有以下特性：

- 可以取地址

- 可以用来初始化左值引用，无论是const还是非const

- 非常量的泛左值可以被赋值，也就是被放在赋值运算符`=`的左边

- 允许类型不完整，也就是只声明不实现

- 可以实现多态

- 有需求时，可以通过左值到右值(`int b = 100; int a; a = b; //b虽然是左值，但转换成了右值来使用`)、数组到指针(数组名是指向数组头元素的指针)或函数到指针(定义函数指针)隐式转换转换成纯右值

  > 数组名实际上不等于指向数组头元素的指针，只是我们在把数组当右值使用时数组名可以隐式转换成指向数组头元素的指针，所以造成了这个误区



### 纯右值

纯右值指的是只能取值大小的表达式。它们可以被分为两种：

1. 没有产生临时对象的表达式，比如表达式`123 + 456`，虽然我们可以知道它的值大小，但我们不知道这个值的位置
2. 临时对象和产生临时对象的表达式，比如`std::string("hello")`是临时对象，一个函数不按引用返回返回值，那么在调用这个函数时也会产生临时对象。我们知道临时对象的值大小，但这个临时对象是匿名的，并且无法知道这个对象的位置

纯右值具有以下特性：

- 无法定位地址
- 任何情况下都不能被赋值
- 能且只能用于初始化非const左值引用
- 可以用于初始化右值引用
- 因为纯右值可以同时初始化非const左值引用和右值引用，传参时如果发生非const左值引用和右值引用的参数重载，优先调用右值引用版本的重载
- 非类非数组的纯右值不能有cv 限定，也就是不能有const和volatile修饰
- 不能实现多态，如果值类型是自定义类，不能包含未重写的虚函数



### 将亡值

将亡值是指可以进行所有权转移，也就是可以被执行“偷窃”或”接管“的泛左值表达式。请注意，不是说没有进行所有权转移就不叫将亡值，只要可以被“偷窃”，它就是将亡值，你要不要“偷窃”和它的值类别无关。这些是将亡值的例子：返回值是右值引用的函数调用(比如`std::move(x);`)、右值的成员。

将亡值同时具有泛左值和右值的特性，这并不奇怪，因为将亡值本身就是可以转成右值的泛左值。

- 【泛左值】有需求时，可以通过左值到右值(int a = b;)、数组到指针(数组名是指向数组头元素的指针)或函数到指针(定义函数指针)隐式转换转换成纯右值
- 【泛左值】可以实现多态
- 【泛左值】允许类型不完整，也就是只声明不实现
- 【右值】无法定位地址
- 【右值】任何情况下都不能被赋值
- 【右值】能且只能用于初始化非const左值引用
- 【右值】可以用于初始化右值引用
- 【右值】因为纯右值可以同时初始化非const左值引用和右值引用，传参时如果发生非const左值引用和右值引用的参数重载，优先调用右值引用版本的重载



### 三者之间的关系

泛左值 = 左值 + 将亡值

右值 = 纯右值 + 将亡值

下面是一些典型的左值和右值例子：

```
int a = 100;		// a是左值，100是右值
int* p = &a;		// 指针p可以取地址，也是左值
*p = 200;			// *p解指针是左值，它返回a的引用
int& a2= a;			// a2和a一样，也是左值
std::string str;	// str是左值
std::string();		// 构造了一个临时的匿名std::string对象，是纯右值
int b = 123 + 456;	// b是左值，但123+456是纯右值
int c = a + b;		// a+b也是纯右值
a++;				// a++先保存临时a，再对a加一，最后返回临时a，返回的临时a是一个将亡值，因此a++是一个左值
++a;				// 先对a加一，再返回a本身，返回的a是一个左值，因此++a是左值
double d = 3.14;
int i = static_cast<int>(d);		// static_cast<int>(d)类型转换模板是一个纯右值
a + b = 200;		// 非法：试图给一个右值赋值
"Hello";			// C风格的字符串是左值，因为他们被保存在常量数据区，可以取地址，可以随时用
[](){cout << "lambda" << endl;}	// lambda表达式是纯右值
string str = std::move(std::string("hello"));	// std::move(std::string("hello"))是将亡值，str是左值

int func1(){		// 返回值是左值，因为它内部返回了已经命名过的变量i
	int i = 100;
	return i;
}
int&& func2() {		// 返回值是一个将亡值，因为它内部执行了所有权的转移
	int i = 100;
    return std::move(i);  
}
int* func3() {		// 返回值是一个纯右值，因为它内部返回了临时对象
    return int(100); 
}
```

有些人说的左值可以放在等号左边，右值只能放在等号右边，这个说法是错误的。

```
int() = a;					// 非法：试图给一个将亡值临时对象赋值
std::string() = "HELLO";	// 通过编译！且调用了临时构造出来的对象的operator=函数
"HELLO" = 123;				// 非法：试图给一个 const char* 类型赋值123
// 带const修饰的变量也具有只读不可写的特性，他们只能出现在等号右边，但他们是左值
```



## 左值引用和右值引用

在C++11中，新增了右值引用的语法，那么相对的，之前的引用就称为左值引用。

右值引用使用两个`&`号来接受一个右值。和左值引用一样，右值引用也必须在声明时就初始化。

```
Type&& reference_variable_name = Rvalue;
```

**右值引用的作用是延长右值的生命周期**，这可能对纯右值没什么用，但对将亡值大有用处。延长的生命周期为该右值引用的生命周期。

**右值引用其实是个左值**，右值需要程序员定义名称，且对右值引用取地址是合法的。为什么右值传递给右值引用之后就会变成左值了呢？因为当使用右值引用指向右值之后，右值引用就“接管”了右值的内存，进而延长右值的生命周期。此时对其取的地址虽然是曾经那个将亡值的地址，但此时将亡值得到了续命，因此在其生命周期内访问这段内存是被允许的。

当然，右值引用能绑定的值并不全都是右值，当右值引用配上模板或auto的某些情况下，其可以即接受左值也接受右值

```
template<typename T>
void f(T&& param){}
f(10); 			// 合法，T&&是右值引用
int x = 10;
f(x); 			// 合法，T&&此时是左值引用

// 不过值得注意的是，const T&&仍只代表右值引用
template<typename T>
void f2(const T&& param){}
f2(10); 			// 合法，const T&&是右值引用
int x2 = 10;
f2(x2); 			// 错误

int x = 123;
auto&& v1 = x;		// 合法，auto&&被推导为左值引用
auto&& v2 = 456;	// 合法，auto&&被推导为右值引用
auto& v3 = x;		// 合法，左值引用
auto& v4 = 789;		// 错误，左值引用只能绑定一个左值变量
```

因此，当`&&`出现时，需要根据上下文推断出到底是不是右值引用。

> 和左值引用一样，右值引用在脱离语言的底层，本质上也是一个指针。左值引用在C++语义中成为类型的别名，但编译器对左值引用就是一个带有非常多限制的常量指针。其实说白了引用是编译器给我们提供的“功能”，也就是说，编译器在我们看不到的地方做了很多别的事情，让一个指针的用法变得如此丰富多彩。但是不管多么丰富多彩，他也只是一个指针而已。右值引用也是如此。我们无法对右值进行取址操作，但C++为我们提供了右值引用，就是帮我们对右值取址并延长其生命周期。因为底层是指针，所以左值引用和右值引用一样都是左值。



## 拷贝、移动、类的构造

在C++11之前，拷贝是非常频繁的操作，而且程序员们也只能进行拷贝，这是没有办法的事情。

**拷贝必须做的是：开辟一块新地方，复制过去。**

而且，我们**需要注意浅拷贝问题**，当我们要拷贝的内容中存在指针时，我们不得不定义拷贝的方式来防止内存泄漏，这样，我们就必须开辟另一块内存空间。

比如`vector`容器的`push_back()`，在往尾部插入一个数据时，它会拷贝一份数据到容器尾端。如果是简单的类型，性能开销尚可接受，但该容器是个模板容器，对于那些复杂的类型，他们的拷贝往往涉及很多操作，比如插入string类。我们知道string内部维护了一个char[]用来保存字符串。在进行拷贝时，string会再开辟一块内存以防止浅拷贝的事情发生。

```
vector<string> str_vec;
str_vec.push_back("hello");	// 【C++11之前】虽然C风格的字符串是左值，但传入一个const char*类型的变量会发生隐式转换，构造一个临时的string对象，然后拷贝到str_vec的尾端
str_vec.push_back(string("world");	// 【C++11之前】构造一个临时的string对象，然后拷贝到str_vec的尾端
```

开辟内存是非常消耗资源的，而且这样拷贝的事情时有发生。类型非常复杂、数据量非常大的时候，拷贝所带来的性能开销不可小觑。在某些情况下，我们对一个对象进行拷贝，然后销毁旧对象，而C++11之后在这些情况下，移动语义能够比拷贝性能更好。

**移动所做的是不进行拷贝，直接让新对象接管旧对象的资源。**

右值引用能延长临时对象的生命周期，因此，可以说右值引用接管了临时对象。那么，临时对象，或者说将亡值的内存又再次被利用起来了，避免了不必要的拷贝。具体怎么转移所有权需要视编译器而定。

因为右值引用实际上并不是对象本身，而是一个引用(底层实现是指针)，这就导致了右值引用并不能代表整个对象，而只是指向对象使他能够被使用而已。移动其实就是定义了一个新变量，然后接手右值引用而已。相比拷贝构造，移动可以使用已有的资源。

> 举一个例子，房子和房产证不是同一个东西，但你有房产证就可以使用房子。
>
> 好比你把房子过继给某人，拷贝就是造一个一模一样的房子，然后把新房子给某人，再销毁原来的房子和房产证，移动就是把房产证直接给某人，某人就可以直接使用这个房子了。

移动可以实现指针指向内存的接管，但对于基础类型，移动和拷贝都是一样的，他们都会以拷贝的形式进行。所以移动语义对复杂的类型和包含指针的类型性能优化要比基础类型多得多。



> 笔者写到这里已经懵了
>
> 谁能回答这几个问题？
>
> 1. 移动语义在底层是怎么实现的？我们知道拷贝是按字节拷贝，那么移动呢？
> 2. 将一个`std::string`类型的变量移动到`std::vector<std::string>`容器内时，一定不发生拷贝吗？
> 3. 接上问，如果在栈区创建一个`std::string`类型的临时变量，然后我们把这个临时变量移动到在堆区的`std::vector<std::string>`容器尾端。那么问题就来了，vector是需要保持内存连续的，此时会发生什么？
> 4. 我们可以将一个纯右值移动给一个左值。比如`int&& i = j * k;`，`j * k`的所有权原来属于谁？



**自定义类需要编写移动构造函数**



我们可以看到C++11之后，标准库`vector`的`push_back`方法有两个版本，左值调用左值常量引用版本，右值调用右值引用版本。

```
push_back(const value_type& __x){..............}
push_back(value_type&& __x){............}
```



呃呃，C++11出来之后，大部分编译器已经对右值进行了优化：

```
vector<string> vec;
vec.push_back(string("hello"));
```

你看起来像是构造了一个临时的string对象，然后再把它拷贝到vec的尾端。但实际上编译器很聪明，它给你优化成了直接在vec的尾端构造这个string对象。这时你只能观察到只调用了一次构造函数，而不会发生拷贝。

同理还有

```
string func() {
	string str("hello");
	return str;
}
int main() {
	string str = func();		// 优化：只调用一次string的构造
}
```

在C++17之前，这个行为是编译器自己决定要不要做，但在C++17之后，这种优化成为了硬性要求。

所以我已经搞不懂为什么要存在移动语义了，看起来编译器比我更适合使用它。

