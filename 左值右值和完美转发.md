## 左值和右值

C++的任何值都分为左值和右值。值可以是常量、变量、数组、对象...

在C++11以后，出现了移动语义，`std::move`和`std::forward`。这些新特性可以提高程序的执行效率，因此，左值和右值的概念变得重要起来。

先来说正论：左值和右值到底是什么。

**左值**：左值是指可以取地址的值，拥有比较长的生命周期，在生命周期内支持随时访问，而且需要程序员起名字。

**右值**：C++中，右值又分为纯右值和将亡值。纯右值指的是那些未明确地址在哪里的值，程序员完全不能知道他们究竟有没有地址，地址在何处。将亡值是指生命周期非常短暂的值，一般来说，这些值是一次性的，用完后在内存中就被销毁了，虽然可以通过某些途径获得将亡值的地址，但这种做法是无意义的。

下面是一些典型的左值和右值例子：

```
int a = 100;		// a是左值，100是右值
int* p = &a;		// 指针p可以取地址，也是左值
*p = 200;			// *p解指针是左值，它返回a的引用
int& a2= a;			// a2和a一样，也是左值
std::string str;	// str是左值
std::string();		// 构造了一个临时的std::string对象，是将亡值
int b = 123 + 456;	// b是左值，但123+456是纯右值
int c = a + b;		// a+b也是纯右值
a++;				// a++先保存临时a，再对a加一，最后返回临时a，返回的临时a是一个将亡值，因此a++是一个左值
++a;				// 先对a加一，再返回a本身，返回的a是一个左值，因此++a是左值
double d = 3.14;
int i = static_cast<int>(d);		// static_cast<int>(d)类型转换模板是一个右值
int func() {return 100;}
int d = func();		// d是左值，但func()返回的是一个将亡值
a + b = 200;		// 非法：试图给一个右值赋值
"Hello";			// C风格的字符串是左值，因为他们被保存在常量数据区，可以取地址，可以随时用
```

有些人说的左值可以放在等号左边，右值只能放在等号右边，这个说法是错误的。

```
int() = a;					// 非法：试图给一个右值赋值
std::string() = "HELLO";	// 通过编译！且调用了临时构造出来的对象的operator=函数。
```





## 拷贝与移动

在C++11之前，拷贝是非常频繁的操作。

比如`vector`容器的`push_back()`，在往尾部插入一个数据时，它会拷贝一份数据到容器尾端。

如果是简单的类型，性能开销尚可接受，但该容器是个模板容器，对于那些复杂的类型，他们的拷贝往往涉及很多操作。

而且我们将一个右值插入到容器内的操作是很常见的

```
vector<string> str_vec;
str_vec.push_back("hello");	// 虽然C风格的字符串是左值，但传入一个const char*类型的变量会发生隐式转换，构造一个临时的string对象
```



## std::move



